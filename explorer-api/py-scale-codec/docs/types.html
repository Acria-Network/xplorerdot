<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>scalecodec.types API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scalecodec.types</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Python SCALE Codec Library
#
# Copyright 2018-2019 openAware BV (NL).
# This file is part of Polkascan.
#
# Polkascan is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Polkascan is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Polkascan. If not, see &lt;http://www.gnu.org/licenses/&gt;.

from datetime import datetime
from scalecodec.base import ScaleType, ScaleBytes
from scalecodec.exceptions import InvalidScaleTypeValueException


class Compact(ScaleType):

    def __init__(self, data=None, **kwargs):
        self.compact_length = 0
        self.compact_bytes = None
        super().__init__(data, **kwargs)

    def process_compact_bytes(self):
        compact_byte = self.get_next_bytes(1)
        try:
            byte_mod = compact_byte[0] % 4
        except IndexError:
            raise InvalidScaleTypeValueException(&#34;Invalid byte for Compact&#34;)

        if byte_mod == 0:
            self.compact_length = 1
        elif byte_mod == 1:
            self.compact_length = 2
        elif byte_mod == 2:
            self.compact_length = 4
        else:
            self.compact_length = int(5 + (compact_byte[0] - 3) / 4)

        if self.compact_length == 1:
            self.compact_bytes = compact_byte
        elif self.compact_length in [2, 4]:
            self.compact_bytes = compact_byte + self.get_next_bytes(self.compact_length - 1)
        else:
            self.compact_bytes = self.get_next_bytes(self.compact_length - 1)

        return self.compact_bytes

    def process(self):

        self.process_compact_bytes()

        if self.sub_type:

            byte_data = self.get_decoder_class(self.sub_type, ScaleBytes(self.compact_bytes)).process()

            if type(byte_data) is int and self.compact_length &lt;= 4:
                return int(byte_data / 4)
            else:
                return byte_data
        else:
            return self.compact_bytes

    def process_encode(self, value):

        if value &lt;= 0b00111111:
            return ScaleBytes(bytearray(int(value &lt;&lt; 2).to_bytes(1, &#39;little&#39;)))

        elif value &lt;= 0b0011111111111111:
            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b01).to_bytes(2, &#39;little&#39;)))

        elif value &lt;= 0b00111111111111111111111111111111:

            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b10).to_bytes(4, &#39;little&#39;)))

        else:
            for bytes_length in range(4, 68):
                if 2 ** (8 * (bytes_length - 1)) &lt;= value &lt; 2 ** (8 * bytes_length):
                    return ScaleBytes(bytearray(
                        ((bytes_length - 4) &lt;&lt; 2 | 0b11).to_bytes(1, &#39;little&#39;) + value.to_bytes(bytes_length,
                                                                                                &#39;little&#39;)))
            else:
                raise ValueError(&#39;{} out of range&#39;.format(value))


# Example of specialized composite implementation for performance improvement
class CompactU32(Compact):

    type_string = &#39;Compact&lt;u32&gt;&#39;

    def process(self):
        self.process_compact_bytes()

        if self.compact_length &lt;= 4:
            return int(int.from_bytes(self.compact_bytes, byteorder=&#39;little&#39;) / 4)
        else:
            return int.from_bytes(self.compact_bytes, byteorder=&#39;little&#39;)

    def process_encode(self, value):

        if value &lt;= 0b00111111:
            return ScaleBytes(bytearray(int(value &lt;&lt; 2).to_bytes(1, &#39;little&#39;)))

        elif value &lt;= 0b0011111111111111:
            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b01).to_bytes(2, &#39;little&#39;)))

        elif value &lt;= 0b00111111111111111111111111111111:

            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b10).to_bytes(4, &#39;little&#39;)))

        else:
            for bytes_length in range(4, 68):
                if 2 ** (8 * (bytes_length-1)) &lt;= value &lt; 2 ** (8 * bytes_length):
                    return ScaleBytes(bytearray(((bytes_length - 4) &lt;&lt; 2 | 0b11).to_bytes(1, &#39;little&#39;) + value.to_bytes(bytes_length, &#39;little&#39;)))
            else:
                raise ValueError(&#39;{} out of range&#39;.format(value))


class Option(ScaleType):
    def process(self):

        option_byte = self.get_next_bytes(1)

        if self.sub_type and option_byte != b&#39;\x00&#39;:
            return self.process_type(self.sub_type).value

        return None

    def process_encode(self, value):

        if value is not None and self.sub_type:
            sub_type_obj = self.get_decoder_class(self.sub_type)
            return ScaleBytes(&#39;0x01&#39;) + sub_type_obj.encode(value)

        return ScaleBytes(&#39;0x00&#39;)


class Bytes(ScaleType):

    type_string = &#39;Vec&lt;u8&gt;&#39;

    def process(self):

        length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
        value = self.get_next_bytes(length)

        try:
            return value.decode()
        except UnicodeDecodeError:
            return &#39;0x{}&#39;.format(value.hex())

    def process_encode(self, value):
        string_length_compact = CompactU32()

        if value[0:2] == &#39;0x&#39;:
            # TODO implicit HexBytes conversion can have unexpected result if string is actually starting with &#39;0x&#39;
            value = bytes.fromhex(value[2:])
            data = string_length_compact.encode(len(value))
            data += value
        else:
            data = string_length_compact.encode(len(value))
            data += value.encode()

        return data


class OptionBytes(ScaleType):

    type_string = &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;

    def process(self):

        option_byte = self.get_next_bytes(1)

        if option_byte != b&#39;\x00&#39;:
            return self.process_type(&#39;Bytes&#39;).value

        return None


# TODO replace in metadata
class String(ScaleType):

    def process(self):

        length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
        value = self.get_next_bytes(length)

        return value.decode()

    def process_encode(self, value):
        string_length_compact = CompactU32()
        data = string_length_compact.encode(len(value))
        data += value.encode()
        return data


class HexBytes(ScaleType):

    def process(self):

        length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        return &#39;0x{}&#39;.format(self.get_next_bytes(length).hex())

    def process_encode(self, value):

        if value[0:2] != &#39;0x&#39;:
            raise ValueError(&#39;HexBytes value should start with &#34;0x&#34;&#39;)

        value = bytes.fromhex(value[2:])

        string_length_compact = CompactU32()
        data = string_length_compact.encode(len(value))
        data += value
        return data


class U8(ScaleType):

    def process(self):
        return self.get_next_u8()

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**8 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(1, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u8&#39;.format(value))


class U16(ScaleType):

    def process(self):
        return int.from_bytes(self.get_next_bytes(2), byteorder=&#39;little&#39;)

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**16 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(2, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u16&#39;.format(value))


class U32(ScaleType):

    def process(self):
        return int.from_bytes(self.get_next_bytes(4), byteorder=&#39;little&#39;)

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**32 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(4, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u32&#39;.format(value))


class U64(ScaleType):

    def process(self):
        return int(int.from_bytes(self.get_next_bytes(8), byteorder=&#39;little&#39;))

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**64 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(8, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u64&#39;.format(value))


class U128(ScaleType):

    def process(self):
        return int(int.from_bytes(self.get_next_bytes(16), byteorder=&#39;little&#39;))

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**128 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(16, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u128&#39;.format(value))


class H160(ScaleType):

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(20).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 22:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 20 bytes long&#39;)
        return ScaleBytes(value)


class H256(ScaleType):

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(32).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 66:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 32 bytes long&#39;)
        return ScaleBytes(value)


class H512(ScaleType):

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(64).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 130:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 64 bytes long&#39;)
        return ScaleBytes(value)


class VecU8Length64(ScaleType):
    type_string = &#39;[u8; 64]&#39;

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(64).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 130:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 64 bytes long&#39;)
        return ScaleBytes(value)


class VecU8Length32(ScaleType):
    type_string = &#39;[u8; 32]&#39;

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(32).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 66:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 32 bytes long&#39;)
        return ScaleBytes(value)


class VecU8Length16(ScaleType):
    type_string = &#39;[u8; 16]&#39;

    def process(self):
        value = self.get_next_bytes(16)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 34:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 16 bytes long&#39;)
        return ScaleBytes(value)


class VecU8Length8(ScaleType):
    type_string = &#39;[u8; 8]&#39;

    def process(self):
        value = self.get_next_bytes(8)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 18:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 8 bytes long&#39;)
        return ScaleBytes(value)


class VecU8Length4(ScaleType):
    type_string = &#39;[u8; 4]&#39;

    def process(self):
        value = self.get_next_bytes(4)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 10:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 4 bytes long&#39;)
        return ScaleBytes(value)


class VecU8Length2(ScaleType):
    type_string = &#39;[u8; 2]&#39;

    def process(self):
        value = self.get_next_bytes(2)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 6:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 2 bytes long&#39;)
        return ScaleBytes(value)


class Struct(ScaleType):

    def __init__(self, data, type_mapping=None, **kwargs):

        if type_mapping:
            self.type_mapping = type_mapping

        super().__init__(data, **kwargs)

    def process(self):

        result = {}
        for key, data_type in self.type_mapping:
            result[key] = self.process_type(data_type, metadata=self.metadata).value

        return result

    def process_encode(self, value):
        data = ScaleBytes(bytearray())

        if type(value) is list:
            if len(value) != len(self.type_mapping):
                raise ValueError(&#39;Element count of value ({}) doesn\&#39;t match type_mapping ({})&#39;.format(len(value), len(self.type_mapping)))

            for idx, (key, data_type) in enumerate(self.type_mapping):

                element_obj = self.get_decoder_class(data_type, metadata=self.metadata)
                data += element_obj.encode(value[idx])

        else:
            for key, data_type in self.type_mapping:
                if key not in value:
                    raise ValueError(&#39;Element &#34;{}&#34; of struct is missing in given value&#39;.format(key))

                element_obj = self.get_decoder_class(data_type, metadata=self.metadata)
                data += element_obj.encode(value[key])

        return data


class Set(ScaleType):
    value_list = []

    def __init__(self, data, value_list=None, **kwargs):
        self.set_value = None
        if value_list:
            self.value_list = value_list

        super().__init__(data, **kwargs)

    def process(self):
        self.set_value = self.process_type(&#39;u64&#39;).value
        result = []
        if self.set_value &gt; 0:

            for value, set_mask in self.value_list.items():
                if self.set_value &amp; set_mask &gt; 0:
                    result.append(value)
        return result

    def process_encode(self, value):
        result = 0
        if type(value) is not list:
            raise ValueError(&#39;Value for encoding a set must be a list&#39;)

        for item, set_mask in self.value_list.items():
            if item in value:
                result += set_mask

        u64_obj = self.get_decoder_class(&#39;u64&#39;)

        return u64_obj.encode(result)



class Era(ScaleType):

    def process(self):

        option_byte = self.get_next_bytes(1).hex()
        if option_byte == &#39;00&#39;:
            return option_byte
        else:
            return option_byte + self.get_next_bytes(1).hex()


class EraIndex(U32):
    pass


class Bool(ScaleType):

    def process(self):
        return self.get_next_bool()

    def process_encode(self, value):
        if value is True:
            return ScaleBytes(&#39;0x01&#39;)
        elif value is False:
            return ScaleBytes(&#39;0x00&#39;)
        else:
            raise ValueError(&#34;Value must be boolean&#34;)


class Moment(U64):
    pass


class CompactMoment(CompactU32):
    type_string = &#39;Compact&lt;Moment&gt;&#39;

    def process(self):
        int_value = super().process()

        if int_value &gt; 10000000000:
            int_value = int_value / 1000

        return datetime.utcfromtimestamp(int_value)

    def serialize(self):
        return self.value.isoformat()


class BoxProposal(ScaleType):
    type_string = &#39;Box&lt;Proposal&gt;&#39;

    def __init__(self, data, **kwargs):
        self.call_index = None
        self.call_function = None
        self.call_module = None
        self.call_args = []
        super().__init__(data, **kwargs)

    def process(self):

        self.call_index = self.get_next_bytes(2).hex()

        self.call_module, self.call_function = self.metadata.call_index[self.call_index]

        for arg in self.call_function.args:
            arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

            self.call_args.append({
                &#39;name&#39;: arg.name,
                &#39;type&#39;: arg.type,
                &#39;value&#39;: arg_type_obj.serialize(),
                &#39;valueRaw&#39;: arg_type_obj.raw_value
            })

        return {
            &#39;call_index&#39;: self.call_index,
            &#39;call_function&#39;: self.call_function.name,
            &#39;call_module&#39;: self.call_module.name,
            &#39;call_args&#39;: self.call_args
        }

    def process_encode(self, value):
        # Check requirements
        if &#39;call_index&#39; in value:
            self.call_index = value[&#39;call_index&#39;]

        elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
            # Look up call module from metadata
            for call_index, (call_module, call_function) in self.metadata.call_index.items():

                if call_module.name == value[&#39;call_module&#39;] and call_function.name == value[&#39;call_function&#39;]:
                    self.call_index = call_index
                    self.call_module = call_module
                    self.call_function = call_function
                    break

            if not self.call_index:
                raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

        elif not self.call_module or not self.call_function:
            raise ValueError(&#39;No call module and function specified&#39;)

        data = ScaleBytes(bytearray.fromhex(self.call_index))

        # Encode call params
        if len(self.call_function.args) &gt; 0:
            for arg in self.call_function.args:
                if arg.name not in value[&#39;call_args&#39;]:
                    raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
                else:
                    param_value = value[&#39;call_args&#39;][arg.name]

                    arg_obj = self.get_decoder_class(arg.type, metadata=self.metadata)
                    data += arg_obj.encode(param_value)

        return data


class ProposalPreimage(Struct):
    type_string = &#39;(Vec&lt;u8&gt;, AccountId, BalanceOf, BlockNumber)&#39;

    type_mapping = (
        (&#34;proposal&#34;, &#34;HexBytes&#34;),
        (&#34;registredBy&#34;, &#34;AccountId&#34;),
        (&#34;deposit&#34;, &#34;BalanceOf&#34;),
        (&#34;blockNumber&#34;, &#34;BlockNumber&#34;)
    )
    def process(self):

        result = {}
        for key, data_type in self.type_mapping:
            result[key] = self.process_type(data_type, metadata=self.metadata).value

        # Replace HexBytes with actual proposal
        result[&#39;proposal&#39;] = Proposal(ScaleBytes(result[&#39;proposal&#39;]), metadata=self.metadata).decode()

        return result


class Proposal(BoxProposal):
    type_string = &#39;&lt;T as Trait&lt;I&gt;&gt;::Proposal&#39;


class ValidatorPrefs(Struct):
    type_string = &#39;(Compact&lt;Balance&gt;)&#39;

    type_mapping = ((&#39;commission&#39;, &#39;Compact&lt;Balance&gt;&#39;),)


class ValidatorPrefsLegacy(Struct):
    type_string = &#39;(Compact&lt;u32&gt;,Compact&lt;Balance&gt;)&#39;

    type_mapping = ((&#39;unstakeThreshold&#39;, &#39;Compact&lt;u32&gt;&#39;), (&#39;validatorPayment&#39;, &#39;Compact&lt;Balance&gt;&#39;))


class Linkage(Struct):
    type_string = &#39;Linkage&lt;AccountId&gt;&#39;

    type_mapping = (
        (&#39;previous&#39;, &#39;Option&lt;AccountId&gt;&#39;),
        (&#39;next&#39;, &#39;Option&lt;AccountId&gt;&#39;)
    )


class AccountId(H256):

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 47:
            from scalecodec.utils.ss58 import ss58_decode
            value = &#39;0x{}&#39;.format(ss58_decode(value))
        return super().process_encode(value)


class AccountIndex(U32):
    pass


class ReferendumIndex(U32):
    pass


class PropIndex(U32):
    pass


class Vote(U8):
    pass


class SessionKey(H256):
    pass


class SessionIndex(U32):
    pass


class Balance(U128):
    pass


class ParaId(U32):
    pass


class Key(Bytes):
    pass


class KeyValue(Struct):
    type_string = &#39;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&#39;
    type_mapping = ((&#39;key&#39;, &#39;Vec&lt;u8&gt;&#39;), (&#39;value&#39;, &#39;Vec&lt;u8&gt;&#39;))


class BalanceOf(Balance):
    pass


class BlockNumber(U64):
    pass


class NewAccountOutcome(CompactU32):
    type_string = &#39;NewAccountOutcome&#39;


class Index(U64):
    pass


class Vec(ScaleType):

    def __init__(self, data=None, **kwargs):
        self.elements = []
        super().__init__(data, **kwargs)

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        result = []
        for _ in range(0, element_count):
            element = self.process_type(self.sub_type)
            self.elements.append(element)
            result.append(element.value)

        return result

    def process_encode(self, value):

        if type(value) is not list:
            raise ValueError(&#34;Provided value is not a list&#34;)

        # encode element count to Compact&lt;u32&gt;
        element_count_compact = CompactU32()

        element_count_compact.encode(len(value))

        data = element_count_compact.data

        for element in value:

            element_obj = self.get_decoder_class(self.sub_type, metadata=self.metadata)
            data += element_obj.encode(element)

        return data


class VecNextAuthority(Vec):
    type_string = &#39;Vec&lt;NextAuthority&gt;&#39;

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        result = []
        for _ in range(0, element_count):
            element = self.process_type(&#39;NextAuthority&#39;)
            self.elements.append(element)
            result.append(element.value)

        return result

# class BalanceTransferExtrinsic(Decoder):
#
#     type_string = &#39;(Address,Compact&lt;Balance&gt;)&#39;
#
#     type_mapping = {&#39;to&#39;: &#39;Address&#39;, &#39;balance&#39;: &#39;Compact&lt;Balance&gt;&#39;}


class Address(ScaleType):

    def __init__(self, data, **kwargs):
        self.account_length = None
        self.account_id = None
        self.account_index = None
        self.account_idx = None
        super().__init__(data, **kwargs)

    def process(self):
        self.account_length = self.get_next_bytes(1)

        if self.account_length == b&#39;\xff&#39;:
            self.account_id = self.get_next_bytes(32).hex()
            self.account_length = self.account_length.hex()

            return self.account_id
        else:
            if self.account_length == b&#39;\xfc&#39;:
                account_index = self.get_next_bytes(2)
            elif self.account_length == b&#39;\xfd&#39;:
                account_index = self.get_next_bytes(4)
            elif self.account_length == b&#39;\xfe&#39;:
                account_index = self.get_next_bytes(8)
            else:
                account_index = self.account_length

            self.account_index = account_index.hex()
            self.account_idx = int.from_bytes(account_index, byteorder=&#39;little&#39;)

            self.account_length = self.account_length.hex()

            return self.account_index

    def process_encode(self, value):

        if type(value) == str and value[0:2] != &#39;0x&#39;:
            # Assume SS58 encoding address
            if len(value) == 47:
                from scalecodec.utils.ss58 import ss58_decode
                value = &#39;0x{}&#39;.format(ss58_decode(value))
            else:
                from scalecodec.utils.ss58 import ss58_decode_account_index
                index_obj = AccountIndex()
                value = index_obj.encode(ss58_decode_account_index(value))

        if type(value) == str and value[0:2] == &#39;0x&#39; and len(value) == 66:
            # value is AccountId
            return ScaleBytes(&#39;0xff{}&#39;.format(value[2:]))
        elif type(value) == int:
            # value is AccountIndex
            raise NotImplementedError(&#39;Encoding of AccountIndex Adresses not supported yet&#39;)
        else:
            raise ValueError(&#39;Value is in unsupported format, expected 32 bytes hex-string for AccountIds or int for AccountIndex&#39;)

    def serialize(self):
        if self.account_id:
            return &#39;0x{}&#39;.format(self.value)
        else:
            return self.value


class RawAddress(Address):
    pass


class Enum(ScaleType):

    value_list = []
    type_mapping = None

    def __init__(self, data, value_list=None, type_mapping=None, **kwargs):

        self.index = None

        if type_mapping:
            self.type_mapping = type_mapping

        if value_list:
            self.value_list = value_list

        super().__init__(data, **kwargs)

    def process(self):
        self.index = int(self.get_next_bytes(1).hex(), 16)

        if self.type_mapping:
            try:
                enum_type_mapping = self.type_mapping[self.index]
                return self.process_type(&#39;Struct&#39;, type_mapping=[enum_type_mapping]).value

            except IndexError:
                raise ValueError(&#34;Index &#39;{}&#39; not present in Enum type mapping&#34;.format(self.index))
        else:
            try:
                return self.value_list[self.index]
            except IndexError:
                raise ValueError(&#34;Index &#39;{}&#39; not present in Enum value list&#34;.format(self.index))

    def process_encode(self, value):
        if self.type_mapping:

            if type(value) != dict:
                raise ValueError(&#34;Value must be a dict when type_mapping is set, not &#39;{}&#39;&#34;.format(value))

            if len(value) != 1:
                raise ValueError(&#34;Value for enum with type_mapping can only have one value&#34;)

            for enum_key, enum_value in value.items():
                for idx, (item_key, item_value) in enumerate(self.type_mapping):
                    if item_key == enum_key:
                        self.index = idx
                        struct_obj = self.get_decoder_class(&#39;Struct&#39;, type_mapping=[self.type_mapping[self.index]])
                        return ScaleBytes(bytearray([self.index])) + struct_obj.encode(value)

                raise ValueError(&#34;Value &#39;{}&#39; not present in type_mapping of this enum&#34;.format(enum_key))

        else:
            for idx, item in enumerate(self.value_list):
                if item == value:
                    self.index = idx
                    return ScaleBytes(bytearray([self.index]))

            raise ValueError(&#34;Value &#39;{}&#39; not present in value list of this enum&#34;.format(value))


class Data(Enum):
    type_mapping = [
        [&#34;None&#34;, &#34;Null&#34;],
        [&#34;Raw&#34;, &#34;Bytes&#34;],
        [&#34;BlakeTwo256&#34;, &#34;H256&#34;],
        [&#34;Sha256&#34;, &#34;H256&#34;],
        [&#34;Keccak256&#34;, &#34;H256&#34;],
        [&#34;ShaThree256&#34;, &#34;H256&#34;]
      ]

    def process(self):

        self.index = int(self.get_next_bytes(1).hex(), 16)

        if self.index == 0:
            return {&#39;None&#39;: None}

        elif self.index &gt;= 1 and self.index &lt;= 33:
            # Determine value of Raw type (length is processed in index byte)
            data = self.get_next_bytes(self.index - 1)

            try:
                value = data.decode()
            except UnicodeDecodeError:
                value = &#39;0x{}&#39;.format(data.hex())
            return {&#34;Raw&#34;: value}

        elif self.index &gt;= 34 and self.index &lt;= 37:

            enum_value = self.type_mapping[self.index - 32][0]

            return {enum_value: self.process_type(self.type_mapping[self.index - 32][1]).value}

        raise ValueError(&#34;Unable to decode Data, invalid indicator byte &#39;{}&#39;&#34;.format(self.index))

    def process_encode(self, value):

        if type(value) != dict:
            raise ValueError(&#34;Value must be a dict when type_mapping is set, not &#39;{}&#39;&#34;.format(value))

        if len(value) != 1:
            raise ValueError(&#34;Value for enum with type_mapping can only have one value&#34;)

        for enum_key, enum_value in value.items():

            for idx, (item_key, item_value) in enumerate(self.type_mapping):
                if item_key == enum_key:
                    self.index = idx

                    if item_value == &#39;Null&#39;:
                        return ScaleBytes(bytearray([0]))

                    elif item_value == &#39;Bytes&#39;:

                        if enum_value[0:2] == &#39;0x&#39;:

                            if len(enum_value) &gt; 66:
                                raise ValueError(&#34;Raw type in Data cannot exceed 32 bytes&#34;)

                            enum_value = bytes.fromhex(enum_value[2:])
                            data = bytes([len(enum_value) + 1]) + enum_value
                            return ScaleBytes(bytearray(data))
                        else:

                            if len(enum_value) &gt; 32:
                                raise ValueError(&#34;Raw type in Data cannot exceed 32 bytes&#34;)

                            data = bytes([len(enum_value) + 1]) + enum_value.encode()
                            return ScaleBytes(bytearray(data))
                    else:

                        struct_obj = self.get_decoder_class(&#39;Struct&#39;, type_mapping=[self.type_mapping[self.index]])
                        return ScaleBytes(bytearray([self.index])) + struct_obj.encode(value)

            raise ValueError(&#34;Value &#39;{}&#39; not present in type_mapping of this enum&#34;.format(enum_key))


class RewardDestination(Enum):

    value_list = [&#39;Staked&#39;, &#39;Stash&#39;, &#39;Controller&#39;]


class StakingLedger(Struct):
    type_string = &#39;StakingLedger&lt;AccountId, BalanceOf, BlockNumber&gt;&#39;
    type_mapping = (
        (&#39;stash&#39;, &#39;AccountId&#39;),
        (&#39;total&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;active&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;unlocking&#39;, &#39;Vec&lt;UnlockChunk&lt;Balance&gt;&gt;&#39;),
    )


class UnlockChunk(Struct):
    type_string = &#39;UnlockChunk&lt;Balance&gt;&#39;
    type_mapping = (
        (&#39;value&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;era&#39;, &#39;Compact&lt;EraIndex&gt;&#39;),
    )


class Exposure(Struct):
    type_string = &#39;Exposure&lt;AccountId, BalanceOf&gt;&#39;
    type_mapping = (
        (&#39;total&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;own&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;others&#39;, &#39;Vec&lt;IndividualExposure&gt;&#39;),
    )


class IndividualExposure(Struct):
    type_string = &#39;IndividualExposure&lt;AccountId, Balance&gt;&#39;
    type_mapping = (
        (&#39;who&#39;, &#39;AccountId&#39;),
        (&#39;value&#39;, &#39;Compact&lt;Balance&gt;&#39;),
    )


class BabeAuthorityWeight(U64):
    pass


class KeyTypeId(VecU8Length4):
    pass


class Points(U32):
    pass


class EraPoints(Struct):
    type_mapping = (
        (&#39;total&#39;, &#39;Points&#39;),
        (&#39;individual&#39;, &#39;Vec&lt;Points&gt;&#39;),
    )


class VoteThreshold(Enum):

    value_list = [&#39;SuperMajorityApprove&#39;, &#39;SuperMajorityAgainst&#39;, &#39;SimpleMajority&#39;]


class Null(ScaleType):

    def process(self):
        return None

    def process_encode(self, value):
        return ScaleBytes(bytearray())


class InherentOfflineReport(Null):
    pass


class LockPeriods(U8):
    pass


class Hash(H256):
    pass


class VoteIndex(U32):
    pass


class ProposalIndex(U32):
    pass


class Permill(U32):
    pass


class Perbill(U32):
    pass


class ApprovalFlag(U32):
    pass


class SetIndex(U32):
    pass


class AuthorityId(AccountId):
    pass


class ValidatorId(AccountId):
    pass


class AuthorityWeight(U64):
    pass


class StoredPendingChange(Struct):
    type_mapping = (
        (&#39;scheduled_at&#39;, &#39;u32&#39;),
        (&#39;forced&#39;, &#39;u32&#39;),
    )


class ReportIdOf(Hash):
    pass


class StorageHasher(Enum):

    value_list = [&#39;Blake2_128&#39;, &#39;Blake2_256&#39;, &#39;Blake2_128Concat&#39;, &#39;Twox128&#39;, &#39;Twox256&#39;, &#39;Twox64Concat&#39;]

    def is_blake2_128(self):
        return self.index == 0

    def is_blake2_256(self):
        return self.index == 1

    def is_twoblake2_128_concat(self):
        return self.index == 2

    def is_twox128(self):
        return self.index == 3

    def is_twox256(self):
        return self.index == 4

    def is_twox64_concat(self):
        return self.index == 5


class VoterInfo(Struct):
    type_string = &#39;VoterInfo&lt;Balance&gt;&#39;

    type_mapping = (
        (&#39;last_active&#39;, &#39;VoteIndex&#39;),
        (&#39;last_win&#39;, &#39;VoteIndex&#39;),
        (&#39;pot&#39;, &#39;Balance&#39;),
        (&#39;stake&#39;, &#39;Balance&#39;),
    )


class Gas(U64):
    pass


class CodeHash(Hash):
    pass


class PrefabWasmModule(Struct):
    type_string = &#39;wasm::PrefabWasmModule&#39;

    type_mapping = (
        (&#39;scheduleVersion&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;initial&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;maximum&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;_reserved&#39;, &#39;Option&lt;Null&gt;&#39;),
        (&#39;code&#39;, &#39;Bytes&#39;),
    )


class OpaqueNetworkState(Struct):

    type_mapping = (
        (&#39;peerId&#39;, &#39;OpaquePeerId&#39;),
        (&#39;externalAddresses&#39;, &#39;Vec&lt;OpaqueMultiaddr&gt;&#39;),
    )


class OpaquePeerId(Bytes):
    pass


class OpaqueMultiaddr(Bytes):
    pass


class SessionKeysSubstrate(Struct):

    type_mapping = (
        (&#39;grandpa&#39;, &#39;AccountId&#39;),
        (&#39;babe&#39;, &#39;AccountId&#39;),
        (&#39;im_online&#39;, &#39;AccountId&#39;),
    )

class LegacyKeys(Struct):

    type_mapping = (
        (&#39;grandpa&#39;, &#39;AccountId&#39;),
        (&#39;babe&#39;, &#39;AccountId&#39;),
    )


class EdgewareKeys(Struct):
    type_mapping = (
        (&#39;grandpa&#39;, &#39;AccountId&#39;),
    )


class QueuedKeys(Struct):

    type_string = &#39;(ValidatorId, Keys)&#39;

    type_mapping = (
        (&#39;validator&#39;, &#39;ValidatorId&#39;),
        (&#39;keys&#39;, &#39;Keys&#39;),
    )


class LegacyQueuedKeys(Struct):

    type_string = &#39;(ValidatorId, LegacyKeys)&#39;

    type_mapping = (
        (&#39;validator&#39;, &#39;ValidatorId&#39;),
        (&#39;keys&#39;, &#39;LegacyKeys&#39;),
    )


class EdgewareQueuedKeys(Struct):

    type_string = &#39;(ValidatorId, EdgewareKeys)&#39;

    type_mapping = (
        (&#39;validator&#39;, &#39;ValidatorId&#39;),
        (&#39;keys&#39;, &#39;EdgewareKeys&#39;),
    )


class VecQueuedKeys(Vec):
    type_string = &#39;Vec&lt;(ValidatorId, Keys)&gt;&#39;

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
        result = []
        for _ in range(0, element_count):
            element = self.process_type(&#39;QueuedKeys&#39;)
            self.elements.append(element)
            result.append(element.value)

        return result


class EthereumAddress(ScaleType):

    def process(self):
        value = self.get_next_bytes(20)
        return value.hex()

    def process_encode(self, value):
        if value[0:2] == &#39;0x&#39; and len(value) == 42:
            return ScaleBytes(value)
        else:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and must be 20 bytes long&#39;)


class EcdsaSignature(ScaleType):

    def process(self):
        value = self.get_next_bytes(65)
        return value.hex()

    def process_encode(self, value):
        if value[0:2] == &#39;0x&#39; and len(value) == 132:
            return ScaleBytes(value)
        else:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and must be 65 bytes long&#39;)


class BalanceLock(Struct):
    type_string = &#39;BalanceLock&lt;Balance, BlockNumber&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;LockIdentifier&#39;),
        (&#39;amount&#39;, &#39;Balance&#39;),
        (&#39;until&#39;, &#39;U32&#39;),
        (&#39;reasons&#39;, &#39;WithdrawReasons&#39;),
    )


class WithdrawReasons(Enum):

    value_list = [&#39;TransactionPayment&#39;, &#39;Transfer&#39;, &#39;Reserve&#39;, &#39;Fee&#39;]


class Bidder(Enum):
    type_string = &#39;Bidder&lt;AccountId, ParaIdOf&gt;&#39;

    value_list = [&#39;NewBidder&#39;, &#39;ParaId&#39;]


class BlockAttestations(Struct):

    type_mapping = (
        (&#39;receipt&#39;, &#39;CandidateReceipt&#39;),
        (&#39;valid&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
        (&#39;invalid&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
    )


class IncludedBlocks(Struct):

    type_mapping = (
        (&#39;actualNumber&#39;, &#39;BlockNumber&#39;),
        (&#39;session&#39;, &#39;SessionIndex&#39;),
        (&#39;randomSeed&#39;, &#39;H256&#39;),
        (&#39;activeParachains&#39;, &#39;Vec&lt;ParaId&gt;&#39;),
        (&#39;paraBlocks&#39;, &#39;Vec&lt;Hash&gt;&#39;),
    )

class HeadData(Bytes):
    pass


class Conviction(Enum):
    CONVICTION_MASK = 0b01111111
    DEFAULT_CONVICTION = 0b00000000

    value_list = [&#39;None&#39;, &#39;Locked1x&#39;, &#39;Locked2x&#39;, &#39;Locked3x&#39;, &#39;Locked4x&#39;, &#39;Locked5x&#39;, &#39;Locked6x&#39;]


class EraRewards(Struct):

    type_mapping = (
        (&#39;total&#39;, &#39;u32&#39;),
        (&#39;rewards&#39;, &#39;Vec&lt;u32&gt;&#39;),
    )


class SlashJournalEntry(Struct):
    type_mapping = (
        (&#39;who&#39;, &#39;AccountId&#39;),
        (&#39;amount&#39;, &#39;Balance&#39;),
        (&#39;ownSlash&#39;, &#39;Balance&#39;),
    )


class UpwardMessage(Struct):
    type_mapping = (
        (&#39;origin&#39;, &#39;ParachainDispatchOrigin&#39;),
        (&#39;data&#39;, &#39;Bytes&#39;),
    )


class ParachainDispatchOrigin(Enum):
    value_list = [&#39;Signed&#39;, &#39;Parachain&#39;]


class StoredState(Enum):
    value_list = [&#39;Live&#39;, &#39;PendingPause&#39;, &#39;Paused&#39;, &#39;PendingResume&#39;]


class Votes(Struct):
    type_mapping = (
        (&#39;index&#39;, &#39;ProposalIndex&#39;),
        (&#39;threshold&#39;, &#39;MemberCount&#39;),
        (&#39;ayes&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
        (&#39;nays&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
    )


class WinningDataEntry(Struct):
    type_mapping = (
        (&#39;AccountId&#39;, &#39;AccountId&#39;),
        (&#39;ParaIdOf&#39;, &#39;ParaIdOf&#39;),
        (&#39;BalanceOf&#39;, &#39;BalanceOf&#39;),
    )

# Edgeware types
# TODO move to RuntimeConfiguration per network


class IdentityType(Bytes):
    pass


class VoteType(Enum):

    type_string = &#39;voting::VoteType&#39;

    value_list = [&#39;Binary&#39;, &#39;MultiOption&#39;]


class VoteOutcome(ScaleType):

    def process(self):
        return list(self.get_next_bytes(32))


class Identity(Bytes):
    pass


class ProposalTitle(Bytes):
    pass


class ProposalContents(Bytes):
    pass


class ProposalStage(Enum):
    value_list = [&#39;PreVoting&#39;, &#39;Voting&#39;, &#39;Completed&#39;]


class ProposalCategory(Enum):
    value_list = [&#39;Signaling&#39;]


class VoteStage(Enum):
    value_list = [&#39;PreVoting&#39;, &#39;Commit&#39;, &#39;Voting&#39;, &#39;Completed&#39;]


class TallyType(Enum):

    type_string = &#39;voting::TallyType&#39;

    value_list = [&#39;OnePerson&#39;, &#39;OneCoin&#39;]


class Attestation(Bytes):
    pass


# Joystream types
# TODO move to RuntimeConfiguration per network

class ContentId(H256):
    pass


class MemberId(U64):
    pass


class PaidTermId(U64):
    pass


class SubscriptionId(U64):
    pass


class SchemaId(U64):
    pass


class DownloadSessionId(U64):
    pass


class UserInfo(Struct):

    type_mapping = (
        (&#39;handle&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;),
        (&#39;avatar_uri&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;),
        (&#39;about&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;)
    )


class Role(Enum):

    value_list = [&#39;Storage&#39;]


class ContentVisibility(Enum):
    value_list = [&#39;Draft&#39;, &#39;Public&#39;]


class ContentMetadata(Struct):
    type_mapping = (
        (&#39;owner&#39;, &#39;AccountId&#39;),
        (&#39;added_at&#39;, &#39;BlockAndTime&#39;),
        (&#39;children_ids&#39;, &#39;Vec&lt;ContentId&gt;&#39;),
        (&#39;visibility&#39;, &#39;ContentVisibility&#39;),
        (&#39;schema&#39;, &#39;SchemaId&#39;),
        (&#39;json&#39;, &#39;Vec&lt;u8&gt;&#39;),

    )


class ContentMetadataUpdate(Struct):
    type_mapping = (
        (&#39;children_ids&#39;, &#39;Option&lt;Vec&lt;ContentId&gt;&gt;&#39;),
        (&#39;visibility&#39;, &#39;Option&lt;ContentVisibility&gt;&#39;),
        (&#39;schema&#39;, &#39;Option&lt;SchemaId&gt;&#39;),
        (&#39;json&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;)
    )


class LiaisonJudgement(Enum):
    value_list = [&#39;Pending&#39;, &#39;Accepted&#39;, &#39;Rejected&#39;]


class BlockAndTime(Struct):
    type_mapping = (
        (&#39;block&#39;, &#39;BlockNumber&#39;),
        (&#39;time&#39;, &#39;Moment&#39;)
    )


class DataObjectTypeId(U64):
    type_string = &#34;&lt;T as DOTRTrait&gt;::DataObjectTypeId&#34;


class DataObject(Struct):
    type_mapping = (
        (&#39;owner&#39;, &#39;AccountId&#39;),
        (&#39;added_at&#39;, &#39;BlockAndTime&#39;),
        (&#39;type_id&#39;, &#39;DataObjectTypeId&#39;),
        (&#39;size&#39;, &#39;u64&#39;),
        (&#39;liaison&#39;, &#39;AccountId&#39;),
        (&#39;liaison_judgement&#39;, &#39;LiaisonJudgement&#39;),
        (&#39;ipfs_content_id&#39;, &#39;Bytes&#39;),
    )


class DataObjectStorageRelationshipId(U64):
    pass


class IPNSIdentity(Bytes):
    pass


class AccountInfo(Struct):
    type_string = &#39;AccountInfo&lt;BlockNumber&gt;&#39;

    type_mapping = (
        (&#39;identity&#39;, &#39;IPNSIdentity&#39;),
        (&#39;expires_at&#39;, &#39;BlockNumber&#39;),
    )


class DownloadState(Enum):
    value_list = [&#39;Started&#39;, &#39;Ended&#39;]


class DownloadSession(Struct):

    type_mapping = (
        (&#39;content_id&#39;, &#39;ContentId&#39;),
        (&#39;consumer&#39;, &#39;AccountId&#39;),
        (&#39;distributor&#39;, &#39;AccountId&#39;),
        (&#39;initiated_at_block&#39;, &#39;BlockNumber&#39;),
        (&#39;initiated_at_time&#39;, &#39;BlockNumber&#39;),
        (&#39;state&#39;, &#39;DownloadState&#39;),
        (&#39;transmitted_bytes&#39;, &#39;u64&#39;),
    )


class Url(Bytes):
    pass


class EntryMethod(Enum):
    value_list = [&#39;Paid&#39;, &#39;Screening&#39;]


class Profile(Struct):
    type_mapping = (
        (&#39;id&#39;, &#39;MemberId&#39;),
        (&#39;handle&#39;, &#39;Bytes&#39;),
        (&#39;avatar_uri&#39;, &#39;Bytes&#39;),
        (&#39;about&#39;, &#39;Bytes&#39;),
        (&#39;registered_at_block&#39;, &#39;BlockNumber&#39;),
        (&#39;registered_at_time&#39;, &#39;Moment&#39;),
        (&#39;entry&#39;, &#39;EntryMethod&#39;),
        (&#39;suspended&#39;, &#39;bool&#39;),
        (&#39;subscription&#39;, &#39;Option&lt;SubscriptionId&gt;&#39;),
    )


class PaidMembershipTerms(Struct):
    type_mapping = (
        (&#39;id&#39;, &#39;PaidTermId&#39;),
        (&#39;fee&#39;, &#39;BalanceOf&#39;),
        (&#39;text&#39;, &#39;Bytes&#39;),
    )


class ThreadId(U64):
    pass


class InputValidationLengthConstraint(Struct):
    type_mapping = (
        (&#39;min&#39;, &#39;u16&#39;),
        (&#39;max_min_diff&#39;, &#39;u16&#39;),
    )


class BlockchainTimestamp(Struct):
    type_string = &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;

    type_mapping = (
        (&#39;block&#39;, &#39;BlockNumber&#39;),
        (&#39;time&#39;, &#39;Moment&#39;),
    )


class ModerationAction(Struct):
    type_mapping = (
        (&#39;moderated_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;moderator_id&#39;, &#39;AccountId&#39;),
        (&#39;rationale&#39;, &#39;Vec&lt;u8&gt;&#39;),
    )


class PostId(U64):
    pass


class PostTextChange(Struct):
    type_string = &#39;PostTextChange&lt;BlockNumber, Moment&gt;&#39;

    type_mapping = (
        (&#39;expired_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;text&#39;, &#39;Vec&lt;u8&gt;&#39;),
    )


class Post(Struct):
    type_string = &#39;Post&lt;BlockNumber, Moment, AccountId&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;PostId&#39;),
        (&#39;thread_id&#39;, &#39;ThreadId&#39;),
        (&#39;nr_in_thread&#39;, &#39;u32&#39;),
        (&#39;current_text&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;moderation&#39;, &#39;Option&lt;ModerationAction&lt;BlockNumber, Moment, AccountId&gt;&gt;&#39;),
        (&#39;text_change_history&#39;, &#39;Vec&lt;PostTextChange&lt;BlockNumber, Moment&gt;&gt;&#39;),
        (&#39;created_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;author_id&#39;, &#39;AccountId&#39;),

    )


class Thread(Struct):
    type_string = &#39;Thread&lt;BlockNumber, Moment, AccountId&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;ThreadId&#39;),
        (&#39;title&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;category_id&#39;, &#39;CategoryId&#39;),
        (&#39;nr_in_category&#39;, &#39;u32&#39;),
        (&#39;moderation&#39;, &#39;Option&lt;ModerationAction&lt;BlockNumber, Moment, AccountId&gt;&gt;&#39;),
        (&#39;num_unmoderated_posts&#39;, &#39;u32&#39;),
        (&#39;num_moderated_posts&#39;, &#39;u32&#39;),
        (&#39;author_id&#39;, &#39;AccountId&#39;),
        (&#39;created_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;author_id&#39;, &#39;AccountId&#39;),
    )


class CategoryId(U64):
    pass


class ChildPositionInParentCategory(Struct):

    type_mapping = (
        (&#39;parent_id&#39;, &#39;CategoryId&#39;),
        (&#39;child_nr_in_parent_category&#39;, &#39;u32&#39;),
    )


class Category(Struct):
    type_string = &#39;Category&lt;BlockNumber, Moment, AccountId&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;CategoryId&#39;),
        (&#39;title&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;description&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;created_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;deleted&#39;, &#39;bool&#39;),
        (&#39;archived&#39;, &#39;bool&#39;),
        (&#39;num_direct_subcategories&#39;, &#39;u32&#39;),
        (&#39;num_direct_unmoderated_threads&#39;, &#39;u32&#39;),
        (&#39;num_direct_moderated_threads&#39;, &#39;u32&#39;),
        (&#39;position_in_parent_category&#39;, &#39;Option&lt;ChildPositionInParentCategory&gt;&#39;),
        (&#39;moderator_id&#39;, &#39;AccountId&#39;),
    )


class ProposalStatus(Enum):
    value_list = [&#39;Active&#39;, &#39;Cancelled&#39;, &#39;Expired&#39;, &#39;Approved&#39;, &#39;Rejected&#39;, &#39;Slashed&#39;]


class VoteKind(Enum):
    value_list = [&#39;Abstain&#39;, &#39;Approve&#39;, &#39;Reject&#39;, &#39;Slash&#39;]


class RuntimeUpgradeProposal(Struct):
    type_string = &#39;RuntimeUpgradeProposal&lt;AccountId, Balance, BlockNumber, Hash&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;u32&#39;),
        (&#39;proposer&#39;, &#39;AccountId&#39;),
        (&#39;stake&#39;, &#39;Balance&#39;),
        (&#39;name&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;description&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;wasm_hash&#39;, &#39;Hash&#39;),
        (&#39;proposed_at&#39;, &#39;BlockNumber&#39;),
        (&#39;status&#39;, &#39;ProposalStatus&#39;),
    )


class TallyResult(Struct):
    type_string = &#39;TallyResult&lt;BlockNumber&gt;&#39;

    type_mapping = (
        (&#39;proposal_id&#39;, &#39;u32&#39;),
        (&#39;abstentions&#39;, &#39;u32&#39;),
        (&#39;approvals&#39;, &#39;u32&#39;),
        (&#39;rejections&#39;, &#39;u32&#39;),
        (&#39;slashes&#39;, &#39;u32&#39;),
        (&#39;status&#39;, &#39;ProposalStatus&#39;),
        (&#39;finalized_at&#39;, &#39;BlockNumber&#39;),
    )


class Call(ScaleType):

    type_string = &#34;Box&lt;Call&gt;&#34;

    def __init__(self, data, **kwargs):
        self.call_index = None
        self.call_function = None
        self.call_args = []
        self.call_module = None

        super().__init__(data, **kwargs)

    def process(self):

        self.call_index = self.get_next_bytes(2).hex()

        self.call_module, self.call_function = self.metadata.call_index[self.call_index]

        for arg in self.call_function.args:
            arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

            self.call_args.append({
                &#39;name&#39;: arg.name,
                &#39;type&#39;: arg.type,
                &#39;value&#39;: arg_type_obj.serialize(),
                &#39;valueRaw&#39;: arg_type_obj.raw_value
            })

        return {
            &#39;call_index&#39;: self.call_index,
            &#39;call_function&#39;: self.call_function.name,
            &#39;call_module&#39;: self.call_module.name,
            &#39;call_args&#39;: self.call_args
        }

    def process_encode(self, value):
        # Check requirements
        if &#39;call_index&#39; in value:
            self.call_index = value[&#39;call_index&#39;]

        elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
            # Look up call module from metadata
            for call_index, (call_module, call_function) in self.metadata.call_index.items():

                if call_module.name == value[&#39;call_module&#39;] and call_function.name == value[&#39;call_function&#39;]:
                    self.call_index = call_index
                    self.call_module = call_module
                    self.call_function = call_function
                    break

            if not self.call_index:
                raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

        elif not self.call_module or not self.call_function:
            raise ValueError(&#39;No call module and function specified&#39;)

        data = ScaleBytes(bytearray.fromhex(self.call_index))

        # Encode call params
        if len(self.call_function.args) &gt; 0:
            for arg in self.call_function.args:
                if arg.name not in value[&#39;call_args&#39;]:
                    raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
                else:
                    param_value = value[&#39;call_args&#39;][arg.name]

                    arg_obj = self.get_decoder_class(arg.type, metadata=self.metadata)
                    data += arg_obj.encode(param_value)

        return data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scalecodec.types.AccountId"><code class="flex name class">
<span>class <span class="ident">AccountId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccountId(H256):

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 47:
            from scalecodec.utils.ss58 import ss58_decode
            value = &#39;0x{}&#39;.format(ss58_decode(value))
        return super().process_encode(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.AuthorityId" href="#scalecodec.types.AuthorityId">AuthorityId</a></li>
<li><a title="scalecodec.types.ValidatorId" href="#scalecodec.types.ValidatorId">ValidatorId</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.AccountId.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 47:
        from scalecodec.utils.ss58 import ss58_decode
        value = &#39;0x{}&#39;.format(ss58_decode(value))
    return super().process_encode(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.H256.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.AccountIndex"><code class="flex name class">
<span>class <span class="ident">AccountIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccountIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.AccountInfo"><code class="flex name class">
<span>class <span class="ident">AccountInfo</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccountInfo(Struct):
    type_string = &#39;AccountInfo&lt;BlockNumber&gt;&#39;

    type_mapping = (
        (&#39;identity&#39;, &#39;IPNSIdentity&#39;),
        (&#39;expires_at&#39;, &#39;BlockNumber&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.AccountInfo.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.AccountInfo.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Address"><code class="flex name class">
<span>class <span class="ident">Address</span></span>
<span>(</span><span>data, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Address(ScaleType):

    def __init__(self, data, **kwargs):
        self.account_length = None
        self.account_id = None
        self.account_index = None
        self.account_idx = None
        super().__init__(data, **kwargs)

    def process(self):
        self.account_length = self.get_next_bytes(1)

        if self.account_length == b&#39;\xff&#39;:
            self.account_id = self.get_next_bytes(32).hex()
            self.account_length = self.account_length.hex()

            return self.account_id
        else:
            if self.account_length == b&#39;\xfc&#39;:
                account_index = self.get_next_bytes(2)
            elif self.account_length == b&#39;\xfd&#39;:
                account_index = self.get_next_bytes(4)
            elif self.account_length == b&#39;\xfe&#39;:
                account_index = self.get_next_bytes(8)
            else:
                account_index = self.account_length

            self.account_index = account_index.hex()
            self.account_idx = int.from_bytes(account_index, byteorder=&#39;little&#39;)

            self.account_length = self.account_length.hex()

            return self.account_index

    def process_encode(self, value):

        if type(value) == str and value[0:2] != &#39;0x&#39;:
            # Assume SS58 encoding address
            if len(value) == 47:
                from scalecodec.utils.ss58 import ss58_decode
                value = &#39;0x{}&#39;.format(ss58_decode(value))
            else:
                from scalecodec.utils.ss58 import ss58_decode_account_index
                index_obj = AccountIndex()
                value = index_obj.encode(ss58_decode_account_index(value))

        if type(value) == str and value[0:2] == &#39;0x&#39; and len(value) == 66:
            # value is AccountId
            return ScaleBytes(&#39;0xff{}&#39;.format(value[2:]))
        elif type(value) == int:
            # value is AccountIndex
            raise NotImplementedError(&#39;Encoding of AccountIndex Adresses not supported yet&#39;)
        else:
            raise ValueError(&#39;Value is in unsupported format, expected 32 bytes hex-string for AccountIds or int for AccountIndex&#39;)

    def serialize(self):
        if self.account_id:
            return &#39;0x{}&#39;.format(self.value)
        else:
            return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.RawAddress" href="#scalecodec.types.RawAddress">RawAddress</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Address.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    self.account_length = self.get_next_bytes(1)

    if self.account_length == b&#39;\xff&#39;:
        self.account_id = self.get_next_bytes(32).hex()
        self.account_length = self.account_length.hex()

        return self.account_id
    else:
        if self.account_length == b&#39;\xfc&#39;:
            account_index = self.get_next_bytes(2)
        elif self.account_length == b&#39;\xfd&#39;:
            account_index = self.get_next_bytes(4)
        elif self.account_length == b&#39;\xfe&#39;:
            account_index = self.get_next_bytes(8)
        else:
            account_index = self.account_length

        self.account_index = account_index.hex()
        self.account_idx = int.from_bytes(account_index, byteorder=&#39;little&#39;)

        self.account_length = self.account_length.hex()

        return self.account_index</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Address.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if type(value) == str and value[0:2] != &#39;0x&#39;:
        # Assume SS58 encoding address
        if len(value) == 47:
            from scalecodec.utils.ss58 import ss58_decode
            value = &#39;0x{}&#39;.format(ss58_decode(value))
        else:
            from scalecodec.utils.ss58 import ss58_decode_account_index
            index_obj = AccountIndex()
            value = index_obj.encode(ss58_decode_account_index(value))

    if type(value) == str and value[0:2] == &#39;0x&#39; and len(value) == 66:
        # value is AccountId
        return ScaleBytes(&#39;0xff{}&#39;.format(value[2:]))
    elif type(value) == int:
        # value is AccountIndex
        raise NotImplementedError(&#39;Encoding of AccountIndex Adresses not supported yet&#39;)
    else:
        raise ValueError(&#39;Value is in unsupported format, expected 32 bytes hex-string for AccountIds or int for AccountIndex&#39;)</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Address.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self):
    if self.account_id:
        return &#39;0x{}&#39;.format(self.value)
    else:
        return self.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ApprovalFlag"><code class="flex name class">
<span>class <span class="ident">ApprovalFlag</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApprovalFlag(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Attestation"><code class="flex name class">
<span>class <span class="ident">Attestation</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Attestation(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.AuthorityId"><code class="flex name class">
<span>class <span class="ident">AuthorityId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthorityId(AccountId):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.AccountId" href="#scalecodec.types.AccountId">AccountId</a></li>
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.AccountId" href="#scalecodec.types.AccountId">AccountId</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.AccountId.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.AuthorityWeight"><code class="flex name class">
<span>class <span class="ident">AuthorityWeight</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthorityWeight(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BabeAuthorityWeight"><code class="flex name class">
<span>class <span class="ident">BabeAuthorityWeight</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BabeAuthorityWeight(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Balance"><code class="flex name class">
<span>class <span class="ident">Balance</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Balance(U128):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U128" href="#scalecodec.types.U128">U128</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.BalanceOf" href="#scalecodec.types.BalanceOf">BalanceOf</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U128" href="#scalecodec.types.U128">U128</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U128.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BalanceLock"><code class="flex name class">
<span>class <span class="ident">BalanceLock</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BalanceLock(Struct):
    type_string = &#39;BalanceLock&lt;Balance, BlockNumber&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;LockIdentifier&#39;),
        (&#39;amount&#39;, &#39;Balance&#39;),
        (&#39;until&#39;, &#39;U32&#39;),
        (&#39;reasons&#39;, &#39;WithdrawReasons&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.BalanceLock.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.BalanceLock.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BalanceOf"><code class="flex name class">
<span>class <span class="ident">BalanceOf</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BalanceOf(Balance):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Balance" href="#scalecodec.types.Balance">Balance</a></li>
<li><a title="scalecodec.types.U128" href="#scalecodec.types.U128">U128</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Balance" href="#scalecodec.types.Balance">Balance</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Balance.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Bidder"><code class="flex name class">
<span>class <span class="ident">Bidder</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bidder(Enum):
    type_string = &#39;Bidder&lt;AccountId, ParaIdOf&gt;&#39;

    value_list = [&#39;NewBidder&#39;, &#39;ParaId&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Bidder.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BlockAndTime"><code class="flex name class">
<span>class <span class="ident">BlockAndTime</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlockAndTime(Struct):
    type_mapping = (
        (&#39;block&#39;, &#39;BlockNumber&#39;),
        (&#39;time&#39;, &#39;Moment&#39;)
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.BlockAndTime.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BlockAttestations"><code class="flex name class">
<span>class <span class="ident">BlockAttestations</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlockAttestations(Struct):

    type_mapping = (
        (&#39;receipt&#39;, &#39;CandidateReceipt&#39;),
        (&#39;valid&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
        (&#39;invalid&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.BlockAttestations.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BlockNumber"><code class="flex name class">
<span>class <span class="ident">BlockNumber</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlockNumber(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BlockchainTimestamp"><code class="flex name class">
<span>class <span class="ident">BlockchainTimestamp</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlockchainTimestamp(Struct):
    type_string = &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;

    type_mapping = (
        (&#39;block&#39;, &#39;BlockNumber&#39;),
        (&#39;time&#39;, &#39;Moment&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.BlockchainTimestamp.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.BlockchainTimestamp.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Bool"><code class="flex name class">
<span>class <span class="ident">Bool</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bool(ScaleType):

    def process(self):
        return self.get_next_bool()

    def process_encode(self, value):
        if value is True:
            return ScaleBytes(&#39;0x01&#39;)
        elif value is False:
            return ScaleBytes(&#39;0x00&#39;)
        else:
            raise ValueError(&#34;Value must be boolean&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Bool.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return self.get_next_bool()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Bool.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value is True:
        return ScaleBytes(&#39;0x01&#39;)
    elif value is False:
        return ScaleBytes(&#39;0x00&#39;)
    else:
        raise ValueError(&#34;Value must be boolean&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.BoxProposal"><code class="flex name class">
<span>class <span class="ident">BoxProposal</span></span>
<span>(</span><span>data, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoxProposal(ScaleType):
    type_string = &#39;Box&lt;Proposal&gt;&#39;

    def __init__(self, data, **kwargs):
        self.call_index = None
        self.call_function = None
        self.call_module = None
        self.call_args = []
        super().__init__(data, **kwargs)

    def process(self):

        self.call_index = self.get_next_bytes(2).hex()

        self.call_module, self.call_function = self.metadata.call_index[self.call_index]

        for arg in self.call_function.args:
            arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

            self.call_args.append({
                &#39;name&#39;: arg.name,
                &#39;type&#39;: arg.type,
                &#39;value&#39;: arg_type_obj.serialize(),
                &#39;valueRaw&#39;: arg_type_obj.raw_value
            })

        return {
            &#39;call_index&#39;: self.call_index,
            &#39;call_function&#39;: self.call_function.name,
            &#39;call_module&#39;: self.call_module.name,
            &#39;call_args&#39;: self.call_args
        }

    def process_encode(self, value):
        # Check requirements
        if &#39;call_index&#39; in value:
            self.call_index = value[&#39;call_index&#39;]

        elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
            # Look up call module from metadata
            for call_index, (call_module, call_function) in self.metadata.call_index.items():

                if call_module.name == value[&#39;call_module&#39;] and call_function.name == value[&#39;call_function&#39;]:
                    self.call_index = call_index
                    self.call_module = call_module
                    self.call_function = call_function
                    break

            if not self.call_index:
                raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

        elif not self.call_module or not self.call_function:
            raise ValueError(&#39;No call module and function specified&#39;)

        data = ScaleBytes(bytearray.fromhex(self.call_index))

        # Encode call params
        if len(self.call_function.args) &gt; 0:
            for arg in self.call_function.args:
                if arg.name not in value[&#39;call_args&#39;]:
                    raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
                else:
                    param_value = value[&#39;call_args&#39;][arg.name]

                    arg_obj = self.get_decoder_class(arg.type, metadata=self.metadata)
                    data += arg_obj.encode(param_value)

        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Proposal" href="#scalecodec.types.Proposal">Proposal</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.BoxProposal.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.BoxProposal.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    self.call_index = self.get_next_bytes(2).hex()

    self.call_module, self.call_function = self.metadata.call_index[self.call_index]

    for arg in self.call_function.args:
        arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

        self.call_args.append({
            &#39;name&#39;: arg.name,
            &#39;type&#39;: arg.type,
            &#39;value&#39;: arg_type_obj.serialize(),
            &#39;valueRaw&#39;: arg_type_obj.raw_value
        })

    return {
        &#39;call_index&#39;: self.call_index,
        &#39;call_function&#39;: self.call_function.name,
        &#39;call_module&#39;: self.call_module.name,
        &#39;call_args&#39;: self.call_args
    }</code></pre>
</details>
</dd>
<dt id="scalecodec.types.BoxProposal.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    # Check requirements
    if &#39;call_index&#39; in value:
        self.call_index = value[&#39;call_index&#39;]

    elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
        # Look up call module from metadata
        for call_index, (call_module, call_function) in self.metadata.call_index.items():

            if call_module.name == value[&#39;call_module&#39;] and call_function.name == value[&#39;call_function&#39;]:
                self.call_index = call_index
                self.call_module = call_module
                self.call_function = call_function
                break

        if not self.call_index:
            raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

    elif not self.call_module or not self.call_function:
        raise ValueError(&#39;No call module and function specified&#39;)

    data = ScaleBytes(bytearray.fromhex(self.call_index))

    # Encode call params
    if len(self.call_function.args) &gt; 0:
        for arg in self.call_function.args:
            if arg.name not in value[&#39;call_args&#39;]:
                raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
            else:
                param_value = value[&#39;call_args&#39;][arg.name]

                arg_obj = self.get_decoder_class(arg.type, metadata=self.metadata)
                data += arg_obj.encode(param_value)

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Bytes"><code class="flex name class">
<span>class <span class="ident">Bytes</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bytes(ScaleType):

    type_string = &#39;Vec&lt;u8&gt;&#39;

    def process(self):

        length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
        value = self.get_next_bytes(length)

        try:
            return value.decode()
        except UnicodeDecodeError:
            return &#39;0x{}&#39;.format(value.hex())

    def process_encode(self, value):
        string_length_compact = CompactU32()

        if value[0:2] == &#39;0x&#39;:
            # TODO implicit HexBytes conversion can have unexpected result if string is actually starting with &#39;0x&#39;
            value = bytes.fromhex(value[2:])
            data = string_length_compact.encode(len(value))
            data += value
        else:
            data = string_length_compact.encode(len(value))
            data += value.encode()

        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.block.ChangesTrieRoot" href="block.html#scalecodec.block.ChangesTrieRoot">ChangesTrieRoot</a></li>
<li><a title="scalecodec.block.Other" href="block.html#scalecodec.block.Other">Other</a></li>
<li><a title="scalecodec.types.Attestation" href="#scalecodec.types.Attestation">Attestation</a></li>
<li><a title="scalecodec.types.HeadData" href="#scalecodec.types.HeadData">HeadData</a></li>
<li><a title="scalecodec.types.IPNSIdentity" href="#scalecodec.types.IPNSIdentity">IPNSIdentity</a></li>
<li><a title="scalecodec.types.Identity" href="#scalecodec.types.Identity">Identity</a></li>
<li><a title="scalecodec.types.IdentityType" href="#scalecodec.types.IdentityType">IdentityType</a></li>
<li><a title="scalecodec.types.Key" href="#scalecodec.types.Key">Key</a></li>
<li><a title="scalecodec.types.OpaqueMultiaddr" href="#scalecodec.types.OpaqueMultiaddr">OpaqueMultiaddr</a></li>
<li><a title="scalecodec.types.OpaquePeerId" href="#scalecodec.types.OpaquePeerId">OpaquePeerId</a></li>
<li><a title="scalecodec.types.ProposalContents" href="#scalecodec.types.ProposalContents">ProposalContents</a></li>
<li><a title="scalecodec.types.ProposalTitle" href="#scalecodec.types.ProposalTitle">ProposalTitle</a></li>
<li><a title="scalecodec.types.Url" href="#scalecodec.types.Url">Url</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Bytes.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Bytes.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
    value = self.get_next_bytes(length)

    try:
        return value.decode()
    except UnicodeDecodeError:
        return &#39;0x{}&#39;.format(value.hex())</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Bytes.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    string_length_compact = CompactU32()

    if value[0:2] == &#39;0x&#39;:
        # TODO implicit HexBytes conversion can have unexpected result if string is actually starting with &#39;0x&#39;
        value = bytes.fromhex(value[2:])
        data = string_length_compact.encode(len(value))
        data += value
    else:
        data = string_length_compact.encode(len(value))
        data += value.encode()

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Call"><code class="flex name class">
<span>class <span class="ident">Call</span></span>
<span>(</span><span>data, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Call(ScaleType):

    type_string = &#34;Box&lt;Call&gt;&#34;

    def __init__(self, data, **kwargs):
        self.call_index = None
        self.call_function = None
        self.call_args = []
        self.call_module = None

        super().__init__(data, **kwargs)

    def process(self):

        self.call_index = self.get_next_bytes(2).hex()

        self.call_module, self.call_function = self.metadata.call_index[self.call_index]

        for arg in self.call_function.args:
            arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

            self.call_args.append({
                &#39;name&#39;: arg.name,
                &#39;type&#39;: arg.type,
                &#39;value&#39;: arg_type_obj.serialize(),
                &#39;valueRaw&#39;: arg_type_obj.raw_value
            })

        return {
            &#39;call_index&#39;: self.call_index,
            &#39;call_function&#39;: self.call_function.name,
            &#39;call_module&#39;: self.call_module.name,
            &#39;call_args&#39;: self.call_args
        }

    def process_encode(self, value):
        # Check requirements
        if &#39;call_index&#39; in value:
            self.call_index = value[&#39;call_index&#39;]

        elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
            # Look up call module from metadata
            for call_index, (call_module, call_function) in self.metadata.call_index.items():

                if call_module.name == value[&#39;call_module&#39;] and call_function.name == value[&#39;call_function&#39;]:
                    self.call_index = call_index
                    self.call_module = call_module
                    self.call_function = call_function
                    break

            if not self.call_index:
                raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

        elif not self.call_module or not self.call_function:
            raise ValueError(&#39;No call module and function specified&#39;)

        data = ScaleBytes(bytearray.fromhex(self.call_index))

        # Encode call params
        if len(self.call_function.args) &gt; 0:
            for arg in self.call_function.args:
                if arg.name not in value[&#39;call_args&#39;]:
                    raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
                else:
                    param_value = value[&#39;call_args&#39;][arg.name]

                    arg_obj = self.get_decoder_class(arg.type, metadata=self.metadata)
                    data += arg_obj.encode(param_value)

        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Call.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Call.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    self.call_index = self.get_next_bytes(2).hex()

    self.call_module, self.call_function = self.metadata.call_index[self.call_index]

    for arg in self.call_function.args:
        arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

        self.call_args.append({
            &#39;name&#39;: arg.name,
            &#39;type&#39;: arg.type,
            &#39;value&#39;: arg_type_obj.serialize(),
            &#39;valueRaw&#39;: arg_type_obj.raw_value
        })

    return {
        &#39;call_index&#39;: self.call_index,
        &#39;call_function&#39;: self.call_function.name,
        &#39;call_module&#39;: self.call_module.name,
        &#39;call_args&#39;: self.call_args
    }</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Call.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    # Check requirements
    if &#39;call_index&#39; in value:
        self.call_index = value[&#39;call_index&#39;]

    elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
        # Look up call module from metadata
        for call_index, (call_module, call_function) in self.metadata.call_index.items():

            if call_module.name == value[&#39;call_module&#39;] and call_function.name == value[&#39;call_function&#39;]:
                self.call_index = call_index
                self.call_module = call_module
                self.call_function = call_function
                break

        if not self.call_index:
            raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

    elif not self.call_module or not self.call_function:
        raise ValueError(&#39;No call module and function specified&#39;)

    data = ScaleBytes(bytearray.fromhex(self.call_index))

    # Encode call params
    if len(self.call_function.args) &gt; 0:
        for arg in self.call_function.args:
            if arg.name not in value[&#39;call_args&#39;]:
                raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
            else:
                param_value = value[&#39;call_args&#39;][arg.name]

                arg_obj = self.get_decoder_class(arg.type, metadata=self.metadata)
                data += arg_obj.encode(param_value)

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Category"><code class="flex name class">
<span>class <span class="ident">Category</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Category(Struct):
    type_string = &#39;Category&lt;BlockNumber, Moment, AccountId&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;CategoryId&#39;),
        (&#39;title&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;description&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;created_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;deleted&#39;, &#39;bool&#39;),
        (&#39;archived&#39;, &#39;bool&#39;),
        (&#39;num_direct_subcategories&#39;, &#39;u32&#39;),
        (&#39;num_direct_unmoderated_threads&#39;, &#39;u32&#39;),
        (&#39;num_direct_moderated_threads&#39;, &#39;u32&#39;),
        (&#39;position_in_parent_category&#39;, &#39;Option&lt;ChildPositionInParentCategory&gt;&#39;),
        (&#39;moderator_id&#39;, &#39;AccountId&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Category.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.Category.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.CategoryId"><code class="flex name class">
<span>class <span class="ident">CategoryId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CategoryId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ChildPositionInParentCategory"><code class="flex name class">
<span>class <span class="ident">ChildPositionInParentCategory</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChildPositionInParentCategory(Struct):

    type_mapping = (
        (&#39;parent_id&#39;, &#39;CategoryId&#39;),
        (&#39;child_nr_in_parent_category&#39;, &#39;u32&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.ChildPositionInParentCategory.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.CodeHash"><code class="flex name class">
<span>class <span class="ident">CodeHash</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CodeHash(Hash):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Hash" href="#scalecodec.types.Hash">Hash</a></li>
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Hash" href="#scalecodec.types.Hash">Hash</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Hash.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Compact"><code class="flex name class">
<span>class <span class="ident">Compact</span></span>
<span>(</span><span>data=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Compact(ScaleType):

    def __init__(self, data=None, **kwargs):
        self.compact_length = 0
        self.compact_bytes = None
        super().__init__(data, **kwargs)

    def process_compact_bytes(self):
        compact_byte = self.get_next_bytes(1)
        try:
            byte_mod = compact_byte[0] % 4
        except IndexError:
            raise InvalidScaleTypeValueException(&#34;Invalid byte for Compact&#34;)

        if byte_mod == 0:
            self.compact_length = 1
        elif byte_mod == 1:
            self.compact_length = 2
        elif byte_mod == 2:
            self.compact_length = 4
        else:
            self.compact_length = int(5 + (compact_byte[0] - 3) / 4)

        if self.compact_length == 1:
            self.compact_bytes = compact_byte
        elif self.compact_length in [2, 4]:
            self.compact_bytes = compact_byte + self.get_next_bytes(self.compact_length - 1)
        else:
            self.compact_bytes = self.get_next_bytes(self.compact_length - 1)

        return self.compact_bytes

    def process(self):

        self.process_compact_bytes()

        if self.sub_type:

            byte_data = self.get_decoder_class(self.sub_type, ScaleBytes(self.compact_bytes)).process()

            if type(byte_data) is int and self.compact_length &lt;= 4:
                return int(byte_data / 4)
            else:
                return byte_data
        else:
            return self.compact_bytes

    def process_encode(self, value):

        if value &lt;= 0b00111111:
            return ScaleBytes(bytearray(int(value &lt;&lt; 2).to_bytes(1, &#39;little&#39;)))

        elif value &lt;= 0b0011111111111111:
            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b01).to_bytes(2, &#39;little&#39;)))

        elif value &lt;= 0b00111111111111111111111111111111:

            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b10).to_bytes(4, &#39;little&#39;)))

        else:
            for bytes_length in range(4, 68):
                if 2 ** (8 * (bytes_length - 1)) &lt;= value &lt; 2 ** (8 * bytes_length):
                    return ScaleBytes(bytearray(
                        ((bytes_length - 4) &lt;&lt; 2 | 0b11).to_bytes(1, &#39;little&#39;) + value.to_bytes(bytes_length,
                                                                                                &#39;little&#39;)))
            else:
                raise ValueError(&#39;{} out of range&#39;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.CompactU32" href="#scalecodec.types.CompactU32">CompactU32</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Compact.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    self.process_compact_bytes()

    if self.sub_type:

        byte_data = self.get_decoder_class(self.sub_type, ScaleBytes(self.compact_bytes)).process()

        if type(byte_data) is int and self.compact_length &lt;= 4:
            return int(byte_data / 4)
        else:
            return byte_data
    else:
        return self.compact_bytes</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Compact.process_compact_bytes"><code class="name flex">
<span>def <span class="ident">process_compact_bytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_compact_bytes(self):
    compact_byte = self.get_next_bytes(1)
    try:
        byte_mod = compact_byte[0] % 4
    except IndexError:
        raise InvalidScaleTypeValueException(&#34;Invalid byte for Compact&#34;)

    if byte_mod == 0:
        self.compact_length = 1
    elif byte_mod == 1:
        self.compact_length = 2
    elif byte_mod == 2:
        self.compact_length = 4
    else:
        self.compact_length = int(5 + (compact_byte[0] - 3) / 4)

    if self.compact_length == 1:
        self.compact_bytes = compact_byte
    elif self.compact_length in [2, 4]:
        self.compact_bytes = compact_byte + self.get_next_bytes(self.compact_length - 1)
    else:
        self.compact_bytes = self.get_next_bytes(self.compact_length - 1)

    return self.compact_bytes</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Compact.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if value &lt;= 0b00111111:
        return ScaleBytes(bytearray(int(value &lt;&lt; 2).to_bytes(1, &#39;little&#39;)))

    elif value &lt;= 0b0011111111111111:
        return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b01).to_bytes(2, &#39;little&#39;)))

    elif value &lt;= 0b00111111111111111111111111111111:

        return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b10).to_bytes(4, &#39;little&#39;)))

    else:
        for bytes_length in range(4, 68):
            if 2 ** (8 * (bytes_length - 1)) &lt;= value &lt; 2 ** (8 * bytes_length):
                return ScaleBytes(bytearray(
                    ((bytes_length - 4) &lt;&lt; 2 | 0b11).to_bytes(1, &#39;little&#39;) + value.to_bytes(bytes_length,
                                                                                            &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range&#39;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.CompactMoment"><code class="flex name class">
<span>class <span class="ident">CompactMoment</span></span>
<span>(</span><span>data=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompactMoment(CompactU32):
    type_string = &#39;Compact&lt;Moment&gt;&#39;

    def process(self):
        int_value = super().process()

        if int_value &gt; 10000000000:
            int_value = int_value / 1000

        return datetime.utcfromtimestamp(int_value)

    def serialize(self):
        return self.value.isoformat()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.CompactU32" href="#scalecodec.types.CompactU32">CompactU32</a></li>
<li><a title="scalecodec.types.Compact" href="#scalecodec.types.Compact">Compact</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.CompactMoment.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    int_value = super().process()

    if int_value &gt; 10000000000:
        int_value = int_value / 1000

    return datetime.utcfromtimestamp(int_value)</code></pre>
</details>
</dd>
<dt id="scalecodec.types.CompactMoment.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self):
    return self.value.isoformat()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.CompactU32" href="#scalecodec.types.CompactU32">CompactU32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.CompactU32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.CompactU32.type_string" href="#scalecodec.types.CompactU32.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.CompactU32"><code class="flex name class">
<span>class <span class="ident">CompactU32</span></span>
<span>(</span><span>data=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompactU32(Compact):

    type_string = &#39;Compact&lt;u32&gt;&#39;

    def process(self):
        self.process_compact_bytes()

        if self.compact_length &lt;= 4:
            return int(int.from_bytes(self.compact_bytes, byteorder=&#39;little&#39;) / 4)
        else:
            return int.from_bytes(self.compact_bytes, byteorder=&#39;little&#39;)

    def process_encode(self, value):

        if value &lt;= 0b00111111:
            return ScaleBytes(bytearray(int(value &lt;&lt; 2).to_bytes(1, &#39;little&#39;)))

        elif value &lt;= 0b0011111111111111:
            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b01).to_bytes(2, &#39;little&#39;)))

        elif value &lt;= 0b00111111111111111111111111111111:

            return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b10).to_bytes(4, &#39;little&#39;)))

        else:
            for bytes_length in range(4, 68):
                if 2 ** (8 * (bytes_length-1)) &lt;= value &lt; 2 ** (8 * bytes_length):
                    return ScaleBytes(bytearray(((bytes_length - 4) &lt;&lt; 2 | 0b11).to_bytes(1, &#39;little&#39;) + value.to_bytes(bytes_length, &#39;little&#39;)))
            else:
                raise ValueError(&#39;{} out of range&#39;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Compact" href="#scalecodec.types.Compact">Compact</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.CompactMoment" href="#scalecodec.types.CompactMoment">CompactMoment</a></li>
<li><a title="scalecodec.types.NewAccountOutcome" href="#scalecodec.types.NewAccountOutcome">NewAccountOutcome</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.CompactU32.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.CompactU32.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    self.process_compact_bytes()

    if self.compact_length &lt;= 4:
        return int(int.from_bytes(self.compact_bytes, byteorder=&#39;little&#39;) / 4)
    else:
        return int.from_bytes(self.compact_bytes, byteorder=&#39;little&#39;)</code></pre>
</details>
</dd>
<dt id="scalecodec.types.CompactU32.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if value &lt;= 0b00111111:
        return ScaleBytes(bytearray(int(value &lt;&lt; 2).to_bytes(1, &#39;little&#39;)))

    elif value &lt;= 0b0011111111111111:
        return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b01).to_bytes(2, &#39;little&#39;)))

    elif value &lt;= 0b00111111111111111111111111111111:

        return ScaleBytes(bytearray(int((value &lt;&lt; 2) | 0b10).to_bytes(4, &#39;little&#39;)))

    else:
        for bytes_length in range(4, 68):
            if 2 ** (8 * (bytes_length-1)) &lt;= value &lt; 2 ** (8 * bytes_length):
                return ScaleBytes(bytearray(((bytes_length - 4) &lt;&lt; 2 | 0b11).to_bytes(1, &#39;little&#39;) + value.to_bytes(bytes_length, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range&#39;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Compact" href="#scalecodec.types.Compact">Compact</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Compact.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ContentId"><code class="flex name class">
<span>class <span class="ident">ContentId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentId(H256):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.H256.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ContentMetadata"><code class="flex name class">
<span>class <span class="ident">ContentMetadata</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentMetadata(Struct):
    type_mapping = (
        (&#39;owner&#39;, &#39;AccountId&#39;),
        (&#39;added_at&#39;, &#39;BlockAndTime&#39;),
        (&#39;children_ids&#39;, &#39;Vec&lt;ContentId&gt;&#39;),
        (&#39;visibility&#39;, &#39;ContentVisibility&#39;),
        (&#39;schema&#39;, &#39;SchemaId&#39;),
        (&#39;json&#39;, &#39;Vec&lt;u8&gt;&#39;),

    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.ContentMetadata.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ContentMetadataUpdate"><code class="flex name class">
<span>class <span class="ident">ContentMetadataUpdate</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentMetadataUpdate(Struct):
    type_mapping = (
        (&#39;children_ids&#39;, &#39;Option&lt;Vec&lt;ContentId&gt;&gt;&#39;),
        (&#39;visibility&#39;, &#39;Option&lt;ContentVisibility&gt;&#39;),
        (&#39;schema&#39;, &#39;Option&lt;SchemaId&gt;&#39;),
        (&#39;json&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;)
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.ContentMetadataUpdate.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ContentVisibility"><code class="flex name class">
<span>class <span class="ident">ContentVisibility</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentVisibility(Enum):
    value_list = [&#39;Draft&#39;, &#39;Public&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Conviction"><code class="flex name class">
<span>class <span class="ident">Conviction</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conviction(Enum):
    CONVICTION_MASK = 0b01111111
    DEFAULT_CONVICTION = 0b00000000

    value_list = [&#39;None&#39;, &#39;Locked1x&#39;, &#39;Locked2x&#39;, &#39;Locked3x&#39;, &#39;Locked4x&#39;, &#39;Locked5x&#39;, &#39;Locked6x&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Conviction.CONVICTION_MASK"><code class="name">var <span class="ident">CONVICTION_MASK</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="scalecodec.types.Conviction.DEFAULT_CONVICTION"><code class="name">var <span class="ident">DEFAULT_CONVICTION</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Data(Enum):
    type_mapping = [
        [&#34;None&#34;, &#34;Null&#34;],
        [&#34;Raw&#34;, &#34;Bytes&#34;],
        [&#34;BlakeTwo256&#34;, &#34;H256&#34;],
        [&#34;Sha256&#34;, &#34;H256&#34;],
        [&#34;Keccak256&#34;, &#34;H256&#34;],
        [&#34;ShaThree256&#34;, &#34;H256&#34;]
      ]

    def process(self):

        self.index = int(self.get_next_bytes(1).hex(), 16)

        if self.index == 0:
            return {&#39;None&#39;: None}

        elif self.index &gt;= 1 and self.index &lt;= 33:
            # Determine value of Raw type (length is processed in index byte)
            data = self.get_next_bytes(self.index - 1)

            try:
                value = data.decode()
            except UnicodeDecodeError:
                value = &#39;0x{}&#39;.format(data.hex())
            return {&#34;Raw&#34;: value}

        elif self.index &gt;= 34 and self.index &lt;= 37:

            enum_value = self.type_mapping[self.index - 32][0]

            return {enum_value: self.process_type(self.type_mapping[self.index - 32][1]).value}

        raise ValueError(&#34;Unable to decode Data, invalid indicator byte &#39;{}&#39;&#34;.format(self.index))

    def process_encode(self, value):

        if type(value) != dict:
            raise ValueError(&#34;Value must be a dict when type_mapping is set, not &#39;{}&#39;&#34;.format(value))

        if len(value) != 1:
            raise ValueError(&#34;Value for enum with type_mapping can only have one value&#34;)

        for enum_key, enum_value in value.items():

            for idx, (item_key, item_value) in enumerate(self.type_mapping):
                if item_key == enum_key:
                    self.index = idx

                    if item_value == &#39;Null&#39;:
                        return ScaleBytes(bytearray([0]))

                    elif item_value == &#39;Bytes&#39;:

                        if enum_value[0:2] == &#39;0x&#39;:

                            if len(enum_value) &gt; 66:
                                raise ValueError(&#34;Raw type in Data cannot exceed 32 bytes&#34;)

                            enum_value = bytes.fromhex(enum_value[2:])
                            data = bytes([len(enum_value) + 1]) + enum_value
                            return ScaleBytes(bytearray(data))
                        else:

                            if len(enum_value) &gt; 32:
                                raise ValueError(&#34;Raw type in Data cannot exceed 32 bytes&#34;)

                            data = bytes([len(enum_value) + 1]) + enum_value.encode()
                            return ScaleBytes(bytearray(data))
                    else:

                        struct_obj = self.get_decoder_class(&#39;Struct&#39;, type_mapping=[self.type_mapping[self.index]])
                        return ScaleBytes(bytearray([self.index])) + struct_obj.encode(value)

            raise ValueError(&#34;Value &#39;{}&#39; not present in type_mapping of this enum&#34;.format(enum_key))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Data.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Data.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    self.index = int(self.get_next_bytes(1).hex(), 16)

    if self.index == 0:
        return {&#39;None&#39;: None}

    elif self.index &gt;= 1 and self.index &lt;= 33:
        # Determine value of Raw type (length is processed in index byte)
        data = self.get_next_bytes(self.index - 1)

        try:
            value = data.decode()
        except UnicodeDecodeError:
            value = &#39;0x{}&#39;.format(data.hex())
        return {&#34;Raw&#34;: value}

    elif self.index &gt;= 34 and self.index &lt;= 37:

        enum_value = self.type_mapping[self.index - 32][0]

        return {enum_value: self.process_type(self.type_mapping[self.index - 32][1]).value}

    raise ValueError(&#34;Unable to decode Data, invalid indicator byte &#39;{}&#39;&#34;.format(self.index))</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Data.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if type(value) != dict:
        raise ValueError(&#34;Value must be a dict when type_mapping is set, not &#39;{}&#39;&#34;.format(value))

    if len(value) != 1:
        raise ValueError(&#34;Value for enum with type_mapping can only have one value&#34;)

    for enum_key, enum_value in value.items():

        for idx, (item_key, item_value) in enumerate(self.type_mapping):
            if item_key == enum_key:
                self.index = idx

                if item_value == &#39;Null&#39;:
                    return ScaleBytes(bytearray([0]))

                elif item_value == &#39;Bytes&#39;:

                    if enum_value[0:2] == &#39;0x&#39;:

                        if len(enum_value) &gt; 66:
                            raise ValueError(&#34;Raw type in Data cannot exceed 32 bytes&#34;)

                        enum_value = bytes.fromhex(enum_value[2:])
                        data = bytes([len(enum_value) + 1]) + enum_value
                        return ScaleBytes(bytearray(data))
                    else:

                        if len(enum_value) &gt; 32:
                            raise ValueError(&#34;Raw type in Data cannot exceed 32 bytes&#34;)

                        data = bytes([len(enum_value) + 1]) + enum_value.encode()
                        return ScaleBytes(bytearray(data))
                else:

                    struct_obj = self.get_decoder_class(&#39;Struct&#39;, type_mapping=[self.type_mapping[self.index]])
                    return ScaleBytes(bytearray([self.index])) + struct_obj.encode(value)

        raise ValueError(&#34;Value &#39;{}&#39; not present in type_mapping of this enum&#34;.format(enum_key))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.DataObject"><code class="flex name class">
<span>class <span class="ident">DataObject</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataObject(Struct):
    type_mapping = (
        (&#39;owner&#39;, &#39;AccountId&#39;),
        (&#39;added_at&#39;, &#39;BlockAndTime&#39;),
        (&#39;type_id&#39;, &#39;DataObjectTypeId&#39;),
        (&#39;size&#39;, &#39;u64&#39;),
        (&#39;liaison&#39;, &#39;AccountId&#39;),
        (&#39;liaison_judgement&#39;, &#39;LiaisonJudgement&#39;),
        (&#39;ipfs_content_id&#39;, &#39;Bytes&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.DataObject.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.DataObjectStorageRelationshipId"><code class="flex name class">
<span>class <span class="ident">DataObjectStorageRelationshipId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataObjectStorageRelationshipId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.DataObjectTypeId"><code class="flex name class">
<span>class <span class="ident">DataObjectTypeId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataObjectTypeId(U64):
    type_string = &#34;&lt;T as DOTRTrait&gt;::DataObjectTypeId&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.DataObjectTypeId.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.DownloadSession"><code class="flex name class">
<span>class <span class="ident">DownloadSession</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DownloadSession(Struct):

    type_mapping = (
        (&#39;content_id&#39;, &#39;ContentId&#39;),
        (&#39;consumer&#39;, &#39;AccountId&#39;),
        (&#39;distributor&#39;, &#39;AccountId&#39;),
        (&#39;initiated_at_block&#39;, &#39;BlockNumber&#39;),
        (&#39;initiated_at_time&#39;, &#39;BlockNumber&#39;),
        (&#39;state&#39;, &#39;DownloadState&#39;),
        (&#39;transmitted_bytes&#39;, &#39;u64&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.DownloadSession.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.DownloadSessionId"><code class="flex name class">
<span>class <span class="ident">DownloadSessionId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DownloadSessionId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.DownloadState"><code class="flex name class">
<span>class <span class="ident">DownloadState</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DownloadState(Enum):
    value_list = [&#39;Started&#39;, &#39;Ended&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EcdsaSignature"><code class="flex name class">
<span>class <span class="ident">EcdsaSignature</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EcdsaSignature(ScaleType):

    def process(self):
        value = self.get_next_bytes(65)
        return value.hex()

    def process_encode(self, value):
        if value[0:2] == &#39;0x&#39; and len(value) == 132:
            return ScaleBytes(value)
        else:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and must be 65 bytes long&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.EcdsaSignature.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    value = self.get_next_bytes(65)
    return value.hex()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.EcdsaSignature.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] == &#39;0x&#39; and len(value) == 132:
        return ScaleBytes(value)
    else:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and must be 65 bytes long&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EdgewareKeys"><code class="flex name class">
<span>class <span class="ident">EdgewareKeys</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EdgewareKeys(Struct):
    type_mapping = (
        (&#39;grandpa&#39;, &#39;AccountId&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.EdgewareKeys.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EdgewareQueuedKeys"><code class="flex name class">
<span>class <span class="ident">EdgewareQueuedKeys</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EdgewareQueuedKeys(Struct):

    type_string = &#39;(ValidatorId, EdgewareKeys)&#39;

    type_mapping = (
        (&#39;validator&#39;, &#39;ValidatorId&#39;),
        (&#39;keys&#39;, &#39;EdgewareKeys&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.EdgewareQueuedKeys.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.EdgewareQueuedKeys.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EntryMethod"><code class="flex name class">
<span>class <span class="ident">EntryMethod</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EntryMethod(Enum):
    value_list = [&#39;Paid&#39;, &#39;Screening&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Enum"><code class="flex name class">
<span>class <span class="ident">Enum</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Enum(ScaleType):

    value_list = []
    type_mapping = None

    def __init__(self, data, value_list=None, type_mapping=None, **kwargs):

        self.index = None

        if type_mapping:
            self.type_mapping = type_mapping

        if value_list:
            self.value_list = value_list

        super().__init__(data, **kwargs)

    def process(self):
        self.index = int(self.get_next_bytes(1).hex(), 16)

        if self.type_mapping:
            try:
                enum_type_mapping = self.type_mapping[self.index]
                return self.process_type(&#39;Struct&#39;, type_mapping=[enum_type_mapping]).value

            except IndexError:
                raise ValueError(&#34;Index &#39;{}&#39; not present in Enum type mapping&#34;.format(self.index))
        else:
            try:
                return self.value_list[self.index]
            except IndexError:
                raise ValueError(&#34;Index &#39;{}&#39; not present in Enum value list&#34;.format(self.index))

    def process_encode(self, value):
        if self.type_mapping:

            if type(value) != dict:
                raise ValueError(&#34;Value must be a dict when type_mapping is set, not &#39;{}&#39;&#34;.format(value))

            if len(value) != 1:
                raise ValueError(&#34;Value for enum with type_mapping can only have one value&#34;)

            for enum_key, enum_value in value.items():
                for idx, (item_key, item_value) in enumerate(self.type_mapping):
                    if item_key == enum_key:
                        self.index = idx
                        struct_obj = self.get_decoder_class(&#39;Struct&#39;, type_mapping=[self.type_mapping[self.index]])
                        return ScaleBytes(bytearray([self.index])) + struct_obj.encode(value)

                raise ValueError(&#34;Value &#39;{}&#39; not present in type_mapping of this enum&#34;.format(enum_key))

        else:
            for idx, item in enumerate(self.value_list):
                if item == value:
                    self.index = idx
                    return ScaleBytes(bytearray([self.index]))

            raise ValueError(&#34;Value &#39;{}&#39; not present in value list of this enum&#34;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.block.LogDigest" href="block.html#scalecodec.block.LogDigest">LogDigest</a></li>
<li><a title="scalecodec.types.Bidder" href="#scalecodec.types.Bidder">Bidder</a></li>
<li><a title="scalecodec.types.ContentVisibility" href="#scalecodec.types.ContentVisibility">ContentVisibility</a></li>
<li><a title="scalecodec.types.Conviction" href="#scalecodec.types.Conviction">Conviction</a></li>
<li><a title="scalecodec.types.Data" href="#scalecodec.types.Data">Data</a></li>
<li><a title="scalecodec.types.DownloadState" href="#scalecodec.types.DownloadState">DownloadState</a></li>
<li><a title="scalecodec.types.EntryMethod" href="#scalecodec.types.EntryMethod">EntryMethod</a></li>
<li><a title="scalecodec.types.LiaisonJudgement" href="#scalecodec.types.LiaisonJudgement">LiaisonJudgement</a></li>
<li><a title="scalecodec.types.ParachainDispatchOrigin" href="#scalecodec.types.ParachainDispatchOrigin">ParachainDispatchOrigin</a></li>
<li><a title="scalecodec.types.ProposalCategory" href="#scalecodec.types.ProposalCategory">ProposalCategory</a></li>
<li><a title="scalecodec.types.ProposalStage" href="#scalecodec.types.ProposalStage">ProposalStage</a></li>
<li><a title="scalecodec.types.ProposalStatus" href="#scalecodec.types.ProposalStatus">ProposalStatus</a></li>
<li><a title="scalecodec.types.RewardDestination" href="#scalecodec.types.RewardDestination">RewardDestination</a></li>
<li><a title="scalecodec.types.Role" href="#scalecodec.types.Role">Role</a></li>
<li><a title="scalecodec.types.StorageHasher" href="#scalecodec.types.StorageHasher">StorageHasher</a></li>
<li><a title="scalecodec.types.StoredState" href="#scalecodec.types.StoredState">StoredState</a></li>
<li><a title="scalecodec.types.TallyType" href="#scalecodec.types.TallyType">TallyType</a></li>
<li><a title="scalecodec.types.VoteKind" href="#scalecodec.types.VoteKind">VoteKind</a></li>
<li><a title="scalecodec.types.VoteStage" href="#scalecodec.types.VoteStage">VoteStage</a></li>
<li><a title="scalecodec.types.VoteThreshold" href="#scalecodec.types.VoteThreshold">VoteThreshold</a></li>
<li><a title="scalecodec.types.VoteType" href="#scalecodec.types.VoteType">VoteType</a></li>
<li><a title="scalecodec.types.WithdrawReasons" href="#scalecodec.types.WithdrawReasons">WithdrawReasons</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Enum.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="scalecodec.types.Enum.value_list"><code class="name">var <span class="ident">value_list</span></code></dt>
<dd>
<section class="desc"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Enum.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    self.index = int(self.get_next_bytes(1).hex(), 16)

    if self.type_mapping:
        try:
            enum_type_mapping = self.type_mapping[self.index]
            return self.process_type(&#39;Struct&#39;, type_mapping=[enum_type_mapping]).value

        except IndexError:
            raise ValueError(&#34;Index &#39;{}&#39; not present in Enum type mapping&#34;.format(self.index))
    else:
        try:
            return self.value_list[self.index]
        except IndexError:
            raise ValueError(&#34;Index &#39;{}&#39; not present in Enum value list&#34;.format(self.index))</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Enum.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if self.type_mapping:

        if type(value) != dict:
            raise ValueError(&#34;Value must be a dict when type_mapping is set, not &#39;{}&#39;&#34;.format(value))

        if len(value) != 1:
            raise ValueError(&#34;Value for enum with type_mapping can only have one value&#34;)

        for enum_key, enum_value in value.items():
            for idx, (item_key, item_value) in enumerate(self.type_mapping):
                if item_key == enum_key:
                    self.index = idx
                    struct_obj = self.get_decoder_class(&#39;Struct&#39;, type_mapping=[self.type_mapping[self.index]])
                    return ScaleBytes(bytearray([self.index])) + struct_obj.encode(value)

            raise ValueError(&#34;Value &#39;{}&#39; not present in type_mapping of this enum&#34;.format(enum_key))

    else:
        for idx, item in enumerate(self.value_list):
            if item == value:
                self.index = idx
                return ScaleBytes(bytearray([self.index]))

        raise ValueError(&#34;Value &#39;{}&#39; not present in value list of this enum&#34;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Era"><code class="flex name class">
<span>class <span class="ident">Era</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Era(ScaleType):

    def process(self):

        option_byte = self.get_next_bytes(1).hex()
        if option_byte == &#39;00&#39;:
            return option_byte
        else:
            return option_byte + self.get_next_bytes(1).hex()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Era.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    option_byte = self.get_next_bytes(1).hex()
    if option_byte == &#39;00&#39;:
        return option_byte
    else:
        return option_byte + self.get_next_bytes(1).hex()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EraIndex"><code class="flex name class">
<span>class <span class="ident">EraIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EraIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EraPoints"><code class="flex name class">
<span>class <span class="ident">EraPoints</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EraPoints(Struct):
    type_mapping = (
        (&#39;total&#39;, &#39;Points&#39;),
        (&#39;individual&#39;, &#39;Vec&lt;Points&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.EraPoints.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EraRewards"><code class="flex name class">
<span>class <span class="ident">EraRewards</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EraRewards(Struct):

    type_mapping = (
        (&#39;total&#39;, &#39;u32&#39;),
        (&#39;rewards&#39;, &#39;Vec&lt;u32&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.EraRewards.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.EthereumAddress"><code class="flex name class">
<span>class <span class="ident">EthereumAddress</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EthereumAddress(ScaleType):

    def process(self):
        value = self.get_next_bytes(20)
        return value.hex()

    def process_encode(self, value):
        if value[0:2] == &#39;0x&#39; and len(value) == 42:
            return ScaleBytes(value)
        else:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and must be 20 bytes long&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.EthereumAddress.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    value = self.get_next_bytes(20)
    return value.hex()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.EthereumAddress.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] == &#39;0x&#39; and len(value) == 42:
        return ScaleBytes(value)
    else:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and must be 20 bytes long&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Exposure"><code class="flex name class">
<span>class <span class="ident">Exposure</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Exposure(Struct):
    type_string = &#39;Exposure&lt;AccountId, BalanceOf&gt;&#39;
    type_mapping = (
        (&#39;total&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;own&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;others&#39;, &#39;Vec&lt;IndividualExposure&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Exposure.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.Exposure.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Gas"><code class="flex name class">
<span>class <span class="ident">Gas</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gas(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.H160"><code class="flex name class">
<span>class <span class="ident">H160</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class H160(ScaleType):

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(20).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 22:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 20 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.H160.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return &#39;0x{}&#39;.format(self.get_next_bytes(20).hex())</code></pre>
</details>
</dd>
<dt id="scalecodec.types.H160.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 22:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 20 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.H256"><code class="flex name class">
<span>class <span class="ident">H256</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class H256(ScaleType):

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(32).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 66:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 32 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.AccountId" href="#scalecodec.types.AccountId">AccountId</a></li>
<li><a title="scalecodec.types.ContentId" href="#scalecodec.types.ContentId">ContentId</a></li>
<li><a title="scalecodec.types.Hash" href="#scalecodec.types.Hash">Hash</a></li>
<li><a title="scalecodec.types.SessionKey" href="#scalecodec.types.SessionKey">SessionKey</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.H256.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return &#39;0x{}&#39;.format(self.get_next_bytes(32).hex())</code></pre>
</details>
</dd>
<dt id="scalecodec.types.H256.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 66:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 32 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.H512"><code class="flex name class">
<span>class <span class="ident">H512</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class H512(ScaleType):

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(64).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 130:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 64 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.H512.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return &#39;0x{}&#39;.format(self.get_next_bytes(64).hex())</code></pre>
</details>
</dd>
<dt id="scalecodec.types.H512.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 130:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 64 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Hash"><code class="flex name class">
<span>class <span class="ident">Hash</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hash(H256):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.CodeHash" href="#scalecodec.types.CodeHash">CodeHash</a></li>
<li><a title="scalecodec.types.ReportIdOf" href="#scalecodec.types.ReportIdOf">ReportIdOf</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.H256.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.HeadData"><code class="flex name class">
<span>class <span class="ident">HeadData</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeadData(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.HexBytes"><code class="flex name class">
<span>class <span class="ident">HexBytes</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HexBytes(ScaleType):

    def process(self):

        length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        return &#39;0x{}&#39;.format(self.get_next_bytes(length).hex())

    def process_encode(self, value):

        if value[0:2] != &#39;0x&#39;:
            raise ValueError(&#39;HexBytes value should start with &#34;0x&#34;&#39;)

        value = bytes.fromhex(value[2:])

        string_length_compact = CompactU32()
        data = string_length_compact.encode(len(value))
        data += value
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.HexBytes.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

    return &#39;0x{}&#39;.format(self.get_next_bytes(length).hex())</code></pre>
</details>
</dd>
<dt id="scalecodec.types.HexBytes.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if value[0:2] != &#39;0x&#39;:
        raise ValueError(&#39;HexBytes value should start with &#34;0x&#34;&#39;)

    value = bytes.fromhex(value[2:])

    string_length_compact = CompactU32()
    data = string_length_compact.encode(len(value))
    data += value
    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.IPNSIdentity"><code class="flex name class">
<span>class <span class="ident">IPNSIdentity</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IPNSIdentity(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Identity"><code class="flex name class">
<span>class <span class="ident">Identity</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Identity(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.IdentityType"><code class="flex name class">
<span>class <span class="ident">IdentityType</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdentityType(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.IncludedBlocks"><code class="flex name class">
<span>class <span class="ident">IncludedBlocks</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IncludedBlocks(Struct):

    type_mapping = (
        (&#39;actualNumber&#39;, &#39;BlockNumber&#39;),
        (&#39;session&#39;, &#39;SessionIndex&#39;),
        (&#39;randomSeed&#39;, &#39;H256&#39;),
        (&#39;activeParachains&#39;, &#39;Vec&lt;ParaId&gt;&#39;),
        (&#39;paraBlocks&#39;, &#39;Vec&lt;Hash&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.IncludedBlocks.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Index"><code class="flex name class">
<span>class <span class="ident">Index</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Index(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.IndividualExposure"><code class="flex name class">
<span>class <span class="ident">IndividualExposure</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndividualExposure(Struct):
    type_string = &#39;IndividualExposure&lt;AccountId, Balance&gt;&#39;
    type_mapping = (
        (&#39;who&#39;, &#39;AccountId&#39;),
        (&#39;value&#39;, &#39;Compact&lt;Balance&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.IndividualExposure.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.IndividualExposure.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.InherentOfflineReport"><code class="flex name class">
<span>class <span class="ident">InherentOfflineReport</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InherentOfflineReport(Null):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Null" href="#scalecodec.types.Null">Null</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Null" href="#scalecodec.types.Null">Null</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Null.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.InputValidationLengthConstraint"><code class="flex name class">
<span>class <span class="ident">InputValidationLengthConstraint</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputValidationLengthConstraint(Struct):
    type_mapping = (
        (&#39;min&#39;, &#39;u16&#39;),
        (&#39;max_min_diff&#39;, &#39;u16&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.InputValidationLengthConstraint.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Key"><code class="flex name class">
<span>class <span class="ident">Key</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Key(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.KeyTypeId"><code class="flex name class">
<span>class <span class="ident">KeyTypeId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyTypeId(VecU8Length4):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.VecU8Length4" href="#scalecodec.types.VecU8Length4">VecU8Length4</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.VecU8Length4" href="#scalecodec.types.VecU8Length4">VecU8Length4</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.VecU8Length4.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length4.type_string" href="#scalecodec.types.VecU8Length4.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.KeyValue"><code class="flex name class">
<span>class <span class="ident">KeyValue</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyValue(Struct):
    type_string = &#39;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&#39;
    type_mapping = ((&#39;key&#39;, &#39;Vec&lt;u8&gt;&#39;), (&#39;value&#39;, &#39;Vec&lt;u8&gt;&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.KeyValue.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.KeyValue.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.LegacyKeys"><code class="flex name class">
<span>class <span class="ident">LegacyKeys</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LegacyKeys(Struct):

    type_mapping = (
        (&#39;grandpa&#39;, &#39;AccountId&#39;),
        (&#39;babe&#39;, &#39;AccountId&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.LegacyKeys.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.LegacyQueuedKeys"><code class="flex name class">
<span>class <span class="ident">LegacyQueuedKeys</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LegacyQueuedKeys(Struct):

    type_string = &#39;(ValidatorId, LegacyKeys)&#39;

    type_mapping = (
        (&#39;validator&#39;, &#39;ValidatorId&#39;),
        (&#39;keys&#39;, &#39;LegacyKeys&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.LegacyQueuedKeys.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.LegacyQueuedKeys.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.LiaisonJudgement"><code class="flex name class">
<span>class <span class="ident">LiaisonJudgement</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LiaisonJudgement(Enum):
    value_list = [&#39;Pending&#39;, &#39;Accepted&#39;, &#39;Rejected&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Linkage"><code class="flex name class">
<span>class <span class="ident">Linkage</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Linkage(Struct):
    type_string = &#39;Linkage&lt;AccountId&gt;&#39;

    type_mapping = (
        (&#39;previous&#39;, &#39;Option&lt;AccountId&gt;&#39;),
        (&#39;next&#39;, &#39;Option&lt;AccountId&gt;&#39;)
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Linkage.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.Linkage.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.LockPeriods"><code class="flex name class">
<span>class <span class="ident">LockPeriods</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LockPeriods(U8):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U8" href="#scalecodec.types.U8">U8</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U8" href="#scalecodec.types.U8">U8</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U8.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.MemberId"><code class="flex name class">
<span>class <span class="ident">MemberId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemberId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ModerationAction"><code class="flex name class">
<span>class <span class="ident">ModerationAction</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModerationAction(Struct):
    type_mapping = (
        (&#39;moderated_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;moderator_id&#39;, &#39;AccountId&#39;),
        (&#39;rationale&#39;, &#39;Vec&lt;u8&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.ModerationAction.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Moment"><code class="flex name class">
<span>class <span class="ident">Moment</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Moment(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.NewAccountOutcome"><code class="flex name class">
<span>class <span class="ident">NewAccountOutcome</span></span>
<span>(</span><span>data=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NewAccountOutcome(CompactU32):
    type_string = &#39;NewAccountOutcome&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.CompactU32" href="#scalecodec.types.CompactU32">CompactU32</a></li>
<li><a title="scalecodec.types.Compact" href="#scalecodec.types.Compact">Compact</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.CompactU32" href="#scalecodec.types.CompactU32">CompactU32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.CompactU32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.CompactU32.type_string" href="#scalecodec.types.CompactU32.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Null"><code class="flex name class">
<span>class <span class="ident">Null</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Null(ScaleType):

    def process(self):
        return None

    def process_encode(self, value):
        return ScaleBytes(bytearray())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.InherentOfflineReport" href="#scalecodec.types.InherentOfflineReport">InherentOfflineReport</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Null.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return None</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Null.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    return ScaleBytes(bytearray())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.OpaqueMultiaddr"><code class="flex name class">
<span>class <span class="ident">OpaqueMultiaddr</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpaqueMultiaddr(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.OpaqueNetworkState"><code class="flex name class">
<span>class <span class="ident">OpaqueNetworkState</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpaqueNetworkState(Struct):

    type_mapping = (
        (&#39;peerId&#39;, &#39;OpaquePeerId&#39;),
        (&#39;externalAddresses&#39;, &#39;Vec&lt;OpaqueMultiaddr&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.OpaqueNetworkState.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.OpaquePeerId"><code class="flex name class">
<span>class <span class="ident">OpaquePeerId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpaquePeerId(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Option"><code class="flex name class">
<span>class <span class="ident">Option</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Option(ScaleType):
    def process(self):

        option_byte = self.get_next_bytes(1)

        if self.sub_type and option_byte != b&#39;\x00&#39;:
            return self.process_type(self.sub_type).value

        return None

    def process_encode(self, value):

        if value is not None and self.sub_type:
            sub_type_obj = self.get_decoder_class(self.sub_type)
            return ScaleBytes(&#39;0x01&#39;) + sub_type_obj.encode(value)

        return ScaleBytes(&#39;0x00&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Option.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    option_byte = self.get_next_bytes(1)

    if self.sub_type and option_byte != b&#39;\x00&#39;:
        return self.process_type(self.sub_type).value

    return None</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Option.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if value is not None and self.sub_type:
        sub_type_obj = self.get_decoder_class(self.sub_type)
        return ScaleBytes(&#39;0x01&#39;) + sub_type_obj.encode(value)

    return ScaleBytes(&#39;0x00&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.OptionBytes"><code class="flex name class">
<span>class <span class="ident">OptionBytes</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptionBytes(ScaleType):

    type_string = &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;

    def process(self):

        option_byte = self.get_next_bytes(1)

        if option_byte != b&#39;\x00&#39;:
            return self.process_type(&#39;Bytes&#39;).value

        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.OptionBytes.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.OptionBytes.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    option_byte = self.get_next_bytes(1)

    if option_byte != b&#39;\x00&#39;:
        return self.process_type(&#39;Bytes&#39;).value

    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.PaidMembershipTerms"><code class="flex name class">
<span>class <span class="ident">PaidMembershipTerms</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PaidMembershipTerms(Struct):
    type_mapping = (
        (&#39;id&#39;, &#39;PaidTermId&#39;),
        (&#39;fee&#39;, &#39;BalanceOf&#39;),
        (&#39;text&#39;, &#39;Bytes&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.PaidMembershipTerms.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.PaidTermId"><code class="flex name class">
<span>class <span class="ident">PaidTermId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PaidTermId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ParaId"><code class="flex name class">
<span>class <span class="ident">ParaId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParaId(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ParachainDispatchOrigin"><code class="flex name class">
<span>class <span class="ident">ParachainDispatchOrigin</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParachainDispatchOrigin(Enum):
    value_list = [&#39;Signed&#39;, &#39;Parachain&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Perbill"><code class="flex name class">
<span>class <span class="ident">Perbill</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Perbill(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Permill"><code class="flex name class">
<span>class <span class="ident">Permill</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Permill(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Points"><code class="flex name class">
<span>class <span class="ident">Points</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Points(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Post"><code class="flex name class">
<span>class <span class="ident">Post</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Post(Struct):
    type_string = &#39;Post&lt;BlockNumber, Moment, AccountId&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;PostId&#39;),
        (&#39;thread_id&#39;, &#39;ThreadId&#39;),
        (&#39;nr_in_thread&#39;, &#39;u32&#39;),
        (&#39;current_text&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;moderation&#39;, &#39;Option&lt;ModerationAction&lt;BlockNumber, Moment, AccountId&gt;&gt;&#39;),
        (&#39;text_change_history&#39;, &#39;Vec&lt;PostTextChange&lt;BlockNumber, Moment&gt;&gt;&#39;),
        (&#39;created_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;author_id&#39;, &#39;AccountId&#39;),

    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Post.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.Post.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.PostId"><code class="flex name class">
<span>class <span class="ident">PostId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.PostTextChange"><code class="flex name class">
<span>class <span class="ident">PostTextChange</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostTextChange(Struct):
    type_string = &#39;PostTextChange&lt;BlockNumber, Moment&gt;&#39;

    type_mapping = (
        (&#39;expired_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;text&#39;, &#39;Vec&lt;u8&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.PostTextChange.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.PostTextChange.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.PrefabWasmModule"><code class="flex name class">
<span>class <span class="ident">PrefabWasmModule</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrefabWasmModule(Struct):
    type_string = &#39;wasm::PrefabWasmModule&#39;

    type_mapping = (
        (&#39;scheduleVersion&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;initial&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;maximum&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;_reserved&#39;, &#39;Option&lt;Null&gt;&#39;),
        (&#39;code&#39;, &#39;Bytes&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.PrefabWasmModule.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.PrefabWasmModule.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Profile"><code class="flex name class">
<span>class <span class="ident">Profile</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Profile(Struct):
    type_mapping = (
        (&#39;id&#39;, &#39;MemberId&#39;),
        (&#39;handle&#39;, &#39;Bytes&#39;),
        (&#39;avatar_uri&#39;, &#39;Bytes&#39;),
        (&#39;about&#39;, &#39;Bytes&#39;),
        (&#39;registered_at_block&#39;, &#39;BlockNumber&#39;),
        (&#39;registered_at_time&#39;, &#39;Moment&#39;),
        (&#39;entry&#39;, &#39;EntryMethod&#39;),
        (&#39;suspended&#39;, &#39;bool&#39;),
        (&#39;subscription&#39;, &#39;Option&lt;SubscriptionId&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Profile.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.PropIndex"><code class="flex name class">
<span>class <span class="ident">PropIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PropIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Proposal"><code class="flex name class">
<span>class <span class="ident">Proposal</span></span>
<span>(</span><span>data, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Proposal(BoxProposal):
    type_string = &#39;&lt;T as Trait&lt;I&gt;&gt;::Proposal&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.BoxProposal" href="#scalecodec.types.BoxProposal">BoxProposal</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.BoxProposal" href="#scalecodec.types.BoxProposal">BoxProposal</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.BoxProposal.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.BoxProposal.type_string" href="#scalecodec.types.BoxProposal.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ProposalCategory"><code class="flex name class">
<span>class <span class="ident">ProposalCategory</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProposalCategory(Enum):
    value_list = [&#39;Signaling&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ProposalContents"><code class="flex name class">
<span>class <span class="ident">ProposalContents</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProposalContents(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ProposalIndex"><code class="flex name class">
<span>class <span class="ident">ProposalIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProposalIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ProposalPreimage"><code class="flex name class">
<span>class <span class="ident">ProposalPreimage</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProposalPreimage(Struct):
    type_string = &#39;(Vec&lt;u8&gt;, AccountId, BalanceOf, BlockNumber)&#39;

    type_mapping = (
        (&#34;proposal&#34;, &#34;HexBytes&#34;),
        (&#34;registredBy&#34;, &#34;AccountId&#34;),
        (&#34;deposit&#34;, &#34;BalanceOf&#34;),
        (&#34;blockNumber&#34;, &#34;BlockNumber&#34;)
    )
    def process(self):

        result = {}
        for key, data_type in self.type_mapping:
            result[key] = self.process_type(data_type, metadata=self.metadata).value

        # Replace HexBytes with actual proposal
        result[&#39;proposal&#39;] = Proposal(ScaleBytes(result[&#39;proposal&#39;]), metadata=self.metadata).decode()

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.ProposalPreimage.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.ProposalPreimage.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.ProposalPreimage.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    result = {}
    for key, data_type in self.type_mapping:
        result[key] = self.process_type(data_type, metadata=self.metadata).value

    # Replace HexBytes with actual proposal
    result[&#39;proposal&#39;] = Proposal(ScaleBytes(result[&#39;proposal&#39;]), metadata=self.metadata).decode()

    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ProposalStage"><code class="flex name class">
<span>class <span class="ident">ProposalStage</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProposalStage(Enum):
    value_list = [&#39;PreVoting&#39;, &#39;Voting&#39;, &#39;Completed&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ProposalStatus"><code class="flex name class">
<span>class <span class="ident">ProposalStatus</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProposalStatus(Enum):
    value_list = [&#39;Active&#39;, &#39;Cancelled&#39;, &#39;Expired&#39;, &#39;Approved&#39;, &#39;Rejected&#39;, &#39;Slashed&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ProposalTitle"><code class="flex name class">
<span>class <span class="ident">ProposalTitle</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProposalTitle(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.QueuedKeys"><code class="flex name class">
<span>class <span class="ident">QueuedKeys</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueuedKeys(Struct):

    type_string = &#39;(ValidatorId, Keys)&#39;

    type_mapping = (
        (&#39;validator&#39;, &#39;ValidatorId&#39;),
        (&#39;keys&#39;, &#39;Keys&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.QueuedKeys.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.QueuedKeys.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.RawAddress"><code class="flex name class">
<span>class <span class="ident">RawAddress</span></span>
<span>(</span><span>data, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawAddress(Address):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Address" href="#scalecodec.types.Address">Address</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Address" href="#scalecodec.types.Address">Address</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Address.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ReferendumIndex"><code class="flex name class">
<span>class <span class="ident">ReferendumIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferendumIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ReportIdOf"><code class="flex name class">
<span>class <span class="ident">ReportIdOf</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReportIdOf(Hash):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Hash" href="#scalecodec.types.Hash">Hash</a></li>
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Hash" href="#scalecodec.types.Hash">Hash</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Hash.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.RewardDestination"><code class="flex name class">
<span>class <span class="ident">RewardDestination</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RewardDestination(Enum):

    value_list = [&#39;Staked&#39;, &#39;Stash&#39;, &#39;Controller&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Role"><code class="flex name class">
<span>class <span class="ident">Role</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Role(Enum):

    value_list = [&#39;Storage&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.RuntimeUpgradeProposal"><code class="flex name class">
<span>class <span class="ident">RuntimeUpgradeProposal</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuntimeUpgradeProposal(Struct):
    type_string = &#39;RuntimeUpgradeProposal&lt;AccountId, Balance, BlockNumber, Hash&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;u32&#39;),
        (&#39;proposer&#39;, &#39;AccountId&#39;),
        (&#39;stake&#39;, &#39;Balance&#39;),
        (&#39;name&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;description&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;wasm_hash&#39;, &#39;Hash&#39;),
        (&#39;proposed_at&#39;, &#39;BlockNumber&#39;),
        (&#39;status&#39;, &#39;ProposalStatus&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.RuntimeUpgradeProposal.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.RuntimeUpgradeProposal.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.SchemaId"><code class="flex name class">
<span>class <span class="ident">SchemaId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SchemaId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.SessionIndex"><code class="flex name class">
<span>class <span class="ident">SessionIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.SessionKey"><code class="flex name class">
<span>class <span class="ident">SessionKey</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionKey(H256):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.H256.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.SessionKeysSubstrate"><code class="flex name class">
<span>class <span class="ident">SessionKeysSubstrate</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionKeysSubstrate(Struct):

    type_mapping = (
        (&#39;grandpa&#39;, &#39;AccountId&#39;),
        (&#39;babe&#39;, &#39;AccountId&#39;),
        (&#39;im_online&#39;, &#39;AccountId&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.SessionKeysSubstrate.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Set"><code class="flex name class">
<span>class <span class="ident">Set</span></span>
<span>(</span><span>data, value_list=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Set(ScaleType):
    value_list = []

    def __init__(self, data, value_list=None, **kwargs):
        self.set_value = None
        if value_list:
            self.value_list = value_list

        super().__init__(data, **kwargs)

    def process(self):
        self.set_value = self.process_type(&#39;u64&#39;).value
        result = []
        if self.set_value &gt; 0:

            for value, set_mask in self.value_list.items():
                if self.set_value &amp; set_mask &gt; 0:
                    result.append(value)
        return result

    def process_encode(self, value):
        result = 0
        if type(value) is not list:
            raise ValueError(&#39;Value for encoding a set must be a list&#39;)

        for item, set_mask in self.value_list.items():
            if item in value:
                result += set_mask

        u64_obj = self.get_decoder_class(&#39;u64&#39;)

        return u64_obj.encode(result)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Set.value_list"><code class="name">var <span class="ident">value_list</span></code></dt>
<dd>
<section class="desc"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Set.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    self.set_value = self.process_type(&#39;u64&#39;).value
    result = []
    if self.set_value &gt; 0:

        for value, set_mask in self.value_list.items():
            if self.set_value &amp; set_mask &gt; 0:
                result.append(value)
    return result</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Set.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    result = 0
    if type(value) is not list:
        raise ValueError(&#39;Value for encoding a set must be a list&#39;)

    for item, set_mask in self.value_list.items():
        if item in value:
            result += set_mask

    u64_obj = self.get_decoder_class(&#39;u64&#39;)

    return u64_obj.encode(result)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.SetIndex"><code class="flex name class">
<span>class <span class="ident">SetIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.SlashJournalEntry"><code class="flex name class">
<span>class <span class="ident">SlashJournalEntry</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SlashJournalEntry(Struct):
    type_mapping = (
        (&#39;who&#39;, &#39;AccountId&#39;),
        (&#39;amount&#39;, &#39;Balance&#39;),
        (&#39;ownSlash&#39;, &#39;Balance&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.SlashJournalEntry.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.StakingLedger"><code class="flex name class">
<span>class <span class="ident">StakingLedger</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StakingLedger(Struct):
    type_string = &#39;StakingLedger&lt;AccountId, BalanceOf, BlockNumber&gt;&#39;
    type_mapping = (
        (&#39;stash&#39;, &#39;AccountId&#39;),
        (&#39;total&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;active&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;unlocking&#39;, &#39;Vec&lt;UnlockChunk&lt;Balance&gt;&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.StakingLedger.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.StakingLedger.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.StorageHasher"><code class="flex name class">
<span>class <span class="ident">StorageHasher</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageHasher(Enum):

    value_list = [&#39;Blake2_128&#39;, &#39;Blake2_256&#39;, &#39;Blake2_128Concat&#39;, &#39;Twox128&#39;, &#39;Twox256&#39;, &#39;Twox64Concat&#39;]

    def is_blake2_128(self):
        return self.index == 0

    def is_blake2_256(self):
        return self.index == 1

    def is_twoblake2_128_concat(self):
        return self.index == 2

    def is_twox128(self):
        return self.index == 3

    def is_twox256(self):
        return self.index == 4

    def is_twox64_concat(self):
        return self.index == 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.StorageHasher.is_blake2_128"><code class="name flex">
<span>def <span class="ident">is_blake2_128</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_blake2_128(self):
    return self.index == 0</code></pre>
</details>
</dd>
<dt id="scalecodec.types.StorageHasher.is_blake2_256"><code class="name flex">
<span>def <span class="ident">is_blake2_256</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_blake2_256(self):
    return self.index == 1</code></pre>
</details>
</dd>
<dt id="scalecodec.types.StorageHasher.is_twoblake2_128_concat"><code class="name flex">
<span>def <span class="ident">is_twoblake2_128_concat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_twoblake2_128_concat(self):
    return self.index == 2</code></pre>
</details>
</dd>
<dt id="scalecodec.types.StorageHasher.is_twox128"><code class="name flex">
<span>def <span class="ident">is_twox128</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_twox128(self):
    return self.index == 3</code></pre>
</details>
</dd>
<dt id="scalecodec.types.StorageHasher.is_twox256"><code class="name flex">
<span>def <span class="ident">is_twox256</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_twox256(self):
    return self.index == 4</code></pre>
</details>
</dd>
<dt id="scalecodec.types.StorageHasher.is_twox64_concat"><code class="name flex">
<span>def <span class="ident">is_twox64_concat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_twox64_concat(self):
    return self.index == 5</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.StoredPendingChange"><code class="flex name class">
<span>class <span class="ident">StoredPendingChange</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoredPendingChange(Struct):
    type_mapping = (
        (&#39;scheduled_at&#39;, &#39;u32&#39;),
        (&#39;forced&#39;, &#39;u32&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.StoredPendingChange.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.StoredState"><code class="flex name class">
<span>class <span class="ident">StoredState</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoredState(Enum):
    value_list = [&#39;Live&#39;, &#39;PendingPause&#39;, &#39;Paused&#39;, &#39;PendingResume&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.String"><code class="flex name class">
<span>class <span class="ident">String</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class String(ScaleType):

    def process(self):

        length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
        value = self.get_next_bytes(length)

        return value.decode()

    def process_encode(self, value):
        string_length_compact = CompactU32()
        data = string_length_compact.encode(len(value))
        data += value.encode()
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.String.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
    value = self.get_next_bytes(length)

    return value.decode()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.String.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    string_length_compact = CompactU32()
    data = string_length_compact.encode(len(value))
    data += value.encode()
    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Struct(ScaleType):

    def __init__(self, data, type_mapping=None, **kwargs):

        if type_mapping:
            self.type_mapping = type_mapping

        super().__init__(data, **kwargs)

    def process(self):

        result = {}
        for key, data_type in self.type_mapping:
            result[key] = self.process_type(data_type, metadata=self.metadata).value

        return result

    def process_encode(self, value):
        data = ScaleBytes(bytearray())

        if type(value) is list:
            if len(value) != len(self.type_mapping):
                raise ValueError(&#39;Element count of value ({}) doesn\&#39;t match type_mapping ({})&#39;.format(len(value), len(self.type_mapping)))

            for idx, (key, data_type) in enumerate(self.type_mapping):

                element_obj = self.get_decoder_class(data_type, metadata=self.metadata)
                data += element_obj.encode(value[idx])

        else:
            for key, data_type in self.type_mapping:
                if key not in value:
                    raise ValueError(&#39;Element &#34;{}&#34; of struct is missing in given value&#39;.format(key))

                element_obj = self.get_decoder_class(data_type, metadata=self.metadata)
                data += element_obj.encode(value[key])

        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.block.Consensus" href="block.html#scalecodec.block.Consensus">Consensus</a></li>
<li><a title="scalecodec.block.PreRuntime" href="block.html#scalecodec.block.PreRuntime">PreRuntime</a></li>
<li><a title="scalecodec.block.Seal" href="block.html#scalecodec.block.Seal">Seal</a></li>
<li><a title="scalecodec.block.SealV0" href="block.html#scalecodec.block.SealV0">SealV0</a></li>
<li><a title="scalecodec.types.AccountInfo" href="#scalecodec.types.AccountInfo">AccountInfo</a></li>
<li><a title="scalecodec.types.BalanceLock" href="#scalecodec.types.BalanceLock">BalanceLock</a></li>
<li><a title="scalecodec.types.BlockAndTime" href="#scalecodec.types.BlockAndTime">BlockAndTime</a></li>
<li><a title="scalecodec.types.BlockAttestations" href="#scalecodec.types.BlockAttestations">BlockAttestations</a></li>
<li><a title="scalecodec.types.BlockchainTimestamp" href="#scalecodec.types.BlockchainTimestamp">BlockchainTimestamp</a></li>
<li><a title="scalecodec.types.Category" href="#scalecodec.types.Category">Category</a></li>
<li><a title="scalecodec.types.ChildPositionInParentCategory" href="#scalecodec.types.ChildPositionInParentCategory">ChildPositionInParentCategory</a></li>
<li><a title="scalecodec.types.ContentMetadata" href="#scalecodec.types.ContentMetadata">ContentMetadata</a></li>
<li><a title="scalecodec.types.ContentMetadataUpdate" href="#scalecodec.types.ContentMetadataUpdate">ContentMetadataUpdate</a></li>
<li><a title="scalecodec.types.DataObject" href="#scalecodec.types.DataObject">DataObject</a></li>
<li><a title="scalecodec.types.DownloadSession" href="#scalecodec.types.DownloadSession">DownloadSession</a></li>
<li><a title="scalecodec.types.EdgewareKeys" href="#scalecodec.types.EdgewareKeys">EdgewareKeys</a></li>
<li><a title="scalecodec.types.EdgewareQueuedKeys" href="#scalecodec.types.EdgewareQueuedKeys">EdgewareQueuedKeys</a></li>
<li><a title="scalecodec.types.EraPoints" href="#scalecodec.types.EraPoints">EraPoints</a></li>
<li><a title="scalecodec.types.EraRewards" href="#scalecodec.types.EraRewards">EraRewards</a></li>
<li><a title="scalecodec.types.Exposure" href="#scalecodec.types.Exposure">Exposure</a></li>
<li><a title="scalecodec.types.IncludedBlocks" href="#scalecodec.types.IncludedBlocks">IncludedBlocks</a></li>
<li><a title="scalecodec.types.IndividualExposure" href="#scalecodec.types.IndividualExposure">IndividualExposure</a></li>
<li><a title="scalecodec.types.InputValidationLengthConstraint" href="#scalecodec.types.InputValidationLengthConstraint">InputValidationLengthConstraint</a></li>
<li><a title="scalecodec.types.KeyValue" href="#scalecodec.types.KeyValue">KeyValue</a></li>
<li><a title="scalecodec.types.LegacyKeys" href="#scalecodec.types.LegacyKeys">LegacyKeys</a></li>
<li><a title="scalecodec.types.LegacyQueuedKeys" href="#scalecodec.types.LegacyQueuedKeys">LegacyQueuedKeys</a></li>
<li><a title="scalecodec.types.Linkage" href="#scalecodec.types.Linkage">Linkage</a></li>
<li><a title="scalecodec.types.ModerationAction" href="#scalecodec.types.ModerationAction">ModerationAction</a></li>
<li><a title="scalecodec.types.OpaqueNetworkState" href="#scalecodec.types.OpaqueNetworkState">OpaqueNetworkState</a></li>
<li><a title="scalecodec.types.PaidMembershipTerms" href="#scalecodec.types.PaidMembershipTerms">PaidMembershipTerms</a></li>
<li><a title="scalecodec.types.Post" href="#scalecodec.types.Post">Post</a></li>
<li><a title="scalecodec.types.PostTextChange" href="#scalecodec.types.PostTextChange">PostTextChange</a></li>
<li><a title="scalecodec.types.PrefabWasmModule" href="#scalecodec.types.PrefabWasmModule">PrefabWasmModule</a></li>
<li><a title="scalecodec.types.Profile" href="#scalecodec.types.Profile">Profile</a></li>
<li><a title="scalecodec.types.ProposalPreimage" href="#scalecodec.types.ProposalPreimage">ProposalPreimage</a></li>
<li><a title="scalecodec.types.QueuedKeys" href="#scalecodec.types.QueuedKeys">QueuedKeys</a></li>
<li><a title="scalecodec.types.RuntimeUpgradeProposal" href="#scalecodec.types.RuntimeUpgradeProposal">RuntimeUpgradeProposal</a></li>
<li><a title="scalecodec.types.SessionKeysSubstrate" href="#scalecodec.types.SessionKeysSubstrate">SessionKeysSubstrate</a></li>
<li><a title="scalecodec.types.SlashJournalEntry" href="#scalecodec.types.SlashJournalEntry">SlashJournalEntry</a></li>
<li><a title="scalecodec.types.StakingLedger" href="#scalecodec.types.StakingLedger">StakingLedger</a></li>
<li><a title="scalecodec.types.StoredPendingChange" href="#scalecodec.types.StoredPendingChange">StoredPendingChange</a></li>
<li><a title="scalecodec.types.TallyResult" href="#scalecodec.types.TallyResult">TallyResult</a></li>
<li><a title="scalecodec.types.Thread" href="#scalecodec.types.Thread">Thread</a></li>
<li><a title="scalecodec.types.UnlockChunk" href="#scalecodec.types.UnlockChunk">UnlockChunk</a></li>
<li><a title="scalecodec.types.UpwardMessage" href="#scalecodec.types.UpwardMessage">UpwardMessage</a></li>
<li><a title="scalecodec.types.UserInfo" href="#scalecodec.types.UserInfo">UserInfo</a></li>
<li><a title="scalecodec.types.ValidatorPrefs" href="#scalecodec.types.ValidatorPrefs">ValidatorPrefs</a></li>
<li><a title="scalecodec.types.ValidatorPrefsLegacy" href="#scalecodec.types.ValidatorPrefsLegacy">ValidatorPrefsLegacy</a></li>
<li><a title="scalecodec.types.VoterInfo" href="#scalecodec.types.VoterInfo">VoterInfo</a></li>
<li><a title="scalecodec.types.Votes" href="#scalecodec.types.Votes">Votes</a></li>
<li><a title="scalecodec.types.WinningDataEntry" href="#scalecodec.types.WinningDataEntry">WinningDataEntry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Struct.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    result = {}
    for key, data_type in self.type_mapping:
        result[key] = self.process_type(data_type, metadata=self.metadata).value

    return result</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Struct.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    data = ScaleBytes(bytearray())

    if type(value) is list:
        if len(value) != len(self.type_mapping):
            raise ValueError(&#39;Element count of value ({}) doesn\&#39;t match type_mapping ({})&#39;.format(len(value), len(self.type_mapping)))

        for idx, (key, data_type) in enumerate(self.type_mapping):

            element_obj = self.get_decoder_class(data_type, metadata=self.metadata)
            data += element_obj.encode(value[idx])

    else:
        for key, data_type in self.type_mapping:
            if key not in value:
                raise ValueError(&#39;Element &#34;{}&#34; of struct is missing in given value&#39;.format(key))

            element_obj = self.get_decoder_class(data_type, metadata=self.metadata)
            data += element_obj.encode(value[key])

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.SubscriptionId"><code class="flex name class">
<span>class <span class="ident">SubscriptionId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubscriptionId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.TallyResult"><code class="flex name class">
<span>class <span class="ident">TallyResult</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TallyResult(Struct):
    type_string = &#39;TallyResult&lt;BlockNumber&gt;&#39;

    type_mapping = (
        (&#39;proposal_id&#39;, &#39;u32&#39;),
        (&#39;abstentions&#39;, &#39;u32&#39;),
        (&#39;approvals&#39;, &#39;u32&#39;),
        (&#39;rejections&#39;, &#39;u32&#39;),
        (&#39;slashes&#39;, &#39;u32&#39;),
        (&#39;status&#39;, &#39;ProposalStatus&#39;),
        (&#39;finalized_at&#39;, &#39;BlockNumber&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.TallyResult.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.TallyResult.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.TallyType"><code class="flex name class">
<span>class <span class="ident">TallyType</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TallyType(Enum):

    type_string = &#39;voting::TallyType&#39;

    value_list = [&#39;OnePerson&#39;, &#39;OneCoin&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.TallyType.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Thread"><code class="flex name class">
<span>class <span class="ident">Thread</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Thread(Struct):
    type_string = &#39;Thread&lt;BlockNumber, Moment, AccountId&gt;&#39;

    type_mapping = (
        (&#39;id&#39;, &#39;ThreadId&#39;),
        (&#39;title&#39;, &#39;Vec&lt;u8&gt;&#39;),
        (&#39;category_id&#39;, &#39;CategoryId&#39;),
        (&#39;nr_in_category&#39;, &#39;u32&#39;),
        (&#39;moderation&#39;, &#39;Option&lt;ModerationAction&lt;BlockNumber, Moment, AccountId&gt;&gt;&#39;),
        (&#39;num_unmoderated_posts&#39;, &#39;u32&#39;),
        (&#39;num_moderated_posts&#39;, &#39;u32&#39;),
        (&#39;author_id&#39;, &#39;AccountId&#39;),
        (&#39;created_at&#39;, &#39;BlockchainTimestamp&lt;BlockNumber, Moment&gt;&#39;),
        (&#39;author_id&#39;, &#39;AccountId&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Thread.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.Thread.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ThreadId"><code class="flex name class">
<span>class <span class="ident">ThreadId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreadId(U64):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U64.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.U128"><code class="flex name class">
<span>class <span class="ident">U128</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class U128(ScaleType):

    def process(self):
        return int(int.from_bytes(self.get_next_bytes(16), byteorder=&#39;little&#39;))

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**128 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(16, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u128&#39;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Balance" href="#scalecodec.types.Balance">Balance</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.U128.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return int(int.from_bytes(self.get_next_bytes(16), byteorder=&#39;little&#39;))</code></pre>
</details>
</dd>
<dt id="scalecodec.types.U128.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if 0 &lt;= value &lt;= 2**128 - 1:
        return ScaleBytes(bytearray(int(value).to_bytes(16, &#39;little&#39;)))
    else:
        raise ValueError(&#39;{} out of range for u128&#39;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.U16"><code class="flex name class">
<span>class <span class="ident">U16</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class U16(ScaleType):

    def process(self):
        return int.from_bytes(self.get_next_bytes(2), byteorder=&#39;little&#39;)

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**16 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(2, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u16&#39;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.U16.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return int.from_bytes(self.get_next_bytes(2), byteorder=&#39;little&#39;)</code></pre>
</details>
</dd>
<dt id="scalecodec.types.U16.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if 0 &lt;= value &lt;= 2**16 - 1:
        return ScaleBytes(bytearray(int(value).to_bytes(2, &#39;little&#39;)))
    else:
        raise ValueError(&#39;{} out of range for u16&#39;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.U32"><code class="flex name class">
<span>class <span class="ident">U32</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class U32(ScaleType):

    def process(self):
        return int.from_bytes(self.get_next_bytes(4), byteorder=&#39;little&#39;)

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**32 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(4, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u32&#39;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.AccountIndex" href="#scalecodec.types.AccountIndex">AccountIndex</a></li>
<li><a title="scalecodec.types.ApprovalFlag" href="#scalecodec.types.ApprovalFlag">ApprovalFlag</a></li>
<li><a title="scalecodec.types.EraIndex" href="#scalecodec.types.EraIndex">EraIndex</a></li>
<li><a title="scalecodec.types.ParaId" href="#scalecodec.types.ParaId">ParaId</a></li>
<li><a title="scalecodec.types.Perbill" href="#scalecodec.types.Perbill">Perbill</a></li>
<li><a title="scalecodec.types.Permill" href="#scalecodec.types.Permill">Permill</a></li>
<li><a title="scalecodec.types.Points" href="#scalecodec.types.Points">Points</a></li>
<li><a title="scalecodec.types.PropIndex" href="#scalecodec.types.PropIndex">PropIndex</a></li>
<li><a title="scalecodec.types.ProposalIndex" href="#scalecodec.types.ProposalIndex">ProposalIndex</a></li>
<li><a title="scalecodec.types.ReferendumIndex" href="#scalecodec.types.ReferendumIndex">ReferendumIndex</a></li>
<li><a title="scalecodec.types.SessionIndex" href="#scalecodec.types.SessionIndex">SessionIndex</a></li>
<li><a title="scalecodec.types.SetIndex" href="#scalecodec.types.SetIndex">SetIndex</a></li>
<li><a title="scalecodec.types.VoteIndex" href="#scalecodec.types.VoteIndex">VoteIndex</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.U32.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return int.from_bytes(self.get_next_bytes(4), byteorder=&#39;little&#39;)</code></pre>
</details>
</dd>
<dt id="scalecodec.types.U32.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if 0 &lt;= value &lt;= 2**32 - 1:
        return ScaleBytes(bytearray(int(value).to_bytes(4, &#39;little&#39;)))
    else:
        raise ValueError(&#39;{} out of range for u32&#39;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.U64"><code class="flex name class">
<span>class <span class="ident">U64</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class U64(ScaleType):

    def process(self):
        return int(int.from_bytes(self.get_next_bytes(8), byteorder=&#39;little&#39;))

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**64 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(8, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u64&#39;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.AuthorityWeight" href="#scalecodec.types.AuthorityWeight">AuthorityWeight</a></li>
<li><a title="scalecodec.types.BabeAuthorityWeight" href="#scalecodec.types.BabeAuthorityWeight">BabeAuthorityWeight</a></li>
<li><a title="scalecodec.types.BlockNumber" href="#scalecodec.types.BlockNumber">BlockNumber</a></li>
<li><a title="scalecodec.types.CategoryId" href="#scalecodec.types.CategoryId">CategoryId</a></li>
<li><a title="scalecodec.types.DataObjectStorageRelationshipId" href="#scalecodec.types.DataObjectStorageRelationshipId">DataObjectStorageRelationshipId</a></li>
<li><a title="scalecodec.types.DataObjectTypeId" href="#scalecodec.types.DataObjectTypeId">DataObjectTypeId</a></li>
<li><a title="scalecodec.types.DownloadSessionId" href="#scalecodec.types.DownloadSessionId">DownloadSessionId</a></li>
<li><a title="scalecodec.types.Gas" href="#scalecodec.types.Gas">Gas</a></li>
<li><a title="scalecodec.types.Index" href="#scalecodec.types.Index">Index</a></li>
<li><a title="scalecodec.types.MemberId" href="#scalecodec.types.MemberId">MemberId</a></li>
<li><a title="scalecodec.types.Moment" href="#scalecodec.types.Moment">Moment</a></li>
<li><a title="scalecodec.types.PaidTermId" href="#scalecodec.types.PaidTermId">PaidTermId</a></li>
<li><a title="scalecodec.types.PostId" href="#scalecodec.types.PostId">PostId</a></li>
<li><a title="scalecodec.types.SchemaId" href="#scalecodec.types.SchemaId">SchemaId</a></li>
<li><a title="scalecodec.types.SubscriptionId" href="#scalecodec.types.SubscriptionId">SubscriptionId</a></li>
<li><a title="scalecodec.types.ThreadId" href="#scalecodec.types.ThreadId">ThreadId</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.U64.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return int(int.from_bytes(self.get_next_bytes(8), byteorder=&#39;little&#39;))</code></pre>
</details>
</dd>
<dt id="scalecodec.types.U64.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if 0 &lt;= value &lt;= 2**64 - 1:
        return ScaleBytes(bytearray(int(value).to_bytes(8, &#39;little&#39;)))
    else:
        raise ValueError(&#39;{} out of range for u64&#39;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.U8"><code class="flex name class">
<span>class <span class="ident">U8</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class U8(ScaleType):

    def process(self):
        return self.get_next_u8()

    def process_encode(self, value):
        if 0 &lt;= value &lt;= 2**8 - 1:
            return ScaleBytes(bytearray(int(value).to_bytes(1, &#39;little&#39;)))
        else:
            raise ValueError(&#39;{} out of range for u8&#39;.format(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.types.LockPeriods" href="#scalecodec.types.LockPeriods">LockPeriods</a></li>
<li><a title="scalecodec.types.Vote" href="#scalecodec.types.Vote">Vote</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.U8.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return self.get_next_u8()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.U8.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if 0 &lt;= value &lt;= 2**8 - 1:
        return ScaleBytes(bytearray(int(value).to_bytes(1, &#39;little&#39;)))
    else:
        raise ValueError(&#39;{} out of range for u8&#39;.format(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.UnlockChunk"><code class="flex name class">
<span>class <span class="ident">UnlockChunk</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnlockChunk(Struct):
    type_string = &#39;UnlockChunk&lt;Balance&gt;&#39;
    type_mapping = (
        (&#39;value&#39;, &#39;Compact&lt;Balance&gt;&#39;),
        (&#39;era&#39;, &#39;Compact&lt;EraIndex&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.UnlockChunk.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.UnlockChunk.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.UpwardMessage"><code class="flex name class">
<span>class <span class="ident">UpwardMessage</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UpwardMessage(Struct):
    type_mapping = (
        (&#39;origin&#39;, &#39;ParachainDispatchOrigin&#39;),
        (&#39;data&#39;, &#39;Bytes&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.UpwardMessage.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Url"><code class="flex name class">
<span>class <span class="ident">Url</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Url(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.UserInfo"><code class="flex name class">
<span>class <span class="ident">UserInfo</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserInfo(Struct):

    type_mapping = (
        (&#39;handle&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;),
        (&#39;avatar_uri&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;),
        (&#39;about&#39;, &#39;Option&lt;Vec&lt;u8&gt;&gt;&#39;)
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.UserInfo.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ValidatorId"><code class="flex name class">
<span>class <span class="ident">ValidatorId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidatorId(AccountId):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.AccountId" href="#scalecodec.types.AccountId">AccountId</a></li>
<li><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.AccountId" href="#scalecodec.types.AccountId">AccountId</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.AccountId.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ValidatorPrefs"><code class="flex name class">
<span>class <span class="ident">ValidatorPrefs</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidatorPrefs(Struct):
    type_string = &#39;(Compact&lt;Balance&gt;)&#39;

    type_mapping = ((&#39;commission&#39;, &#39;Compact&lt;Balance&gt;&#39;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.ValidatorPrefs.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.ValidatorPrefs.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.ValidatorPrefsLegacy"><code class="flex name class">
<span>class <span class="ident">ValidatorPrefsLegacy</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidatorPrefsLegacy(Struct):
    type_string = &#39;(Compact&lt;u32&gt;,Compact&lt;Balance&gt;)&#39;

    type_mapping = ((&#39;unstakeThreshold&#39;, &#39;Compact&lt;u32&gt;&#39;), (&#39;validatorPayment&#39;, &#39;Compact&lt;Balance&gt;&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.ValidatorPrefsLegacy.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.ValidatorPrefsLegacy.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Vec"><code class="flex name class">
<span>class <span class="ident">Vec</span></span>
<span>(</span><span>data=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vec(ScaleType):

    def __init__(self, data=None, **kwargs):
        self.elements = []
        super().__init__(data, **kwargs)

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        result = []
        for _ in range(0, element_count):
            element = self.process_type(self.sub_type)
            self.elements.append(element)
            result.append(element.value)

        return result

    def process_encode(self, value):

        if type(value) is not list:
            raise ValueError(&#34;Provided value is not a list&#34;)

        # encode element count to Compact&lt;u32&gt;
        element_count_compact = CompactU32()

        element_count_compact.encode(len(value))

        data = element_count_compact.data

        for element in value:

            element_obj = self.get_decoder_class(self.sub_type, metadata=self.metadata)
            data += element_obj.encode(element)

        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.block.AuthoritiesChange" href="block.html#scalecodec.block.AuthoritiesChange">AuthoritiesChange</a></li>
<li><a title="scalecodec.block.EventsDecoder" href="block.html#scalecodec.block.EventsDecoder">EventsDecoder</a></li>
<li><a title="scalecodec.types.VecNextAuthority" href="#scalecodec.types.VecNextAuthority">VecNextAuthority</a></li>
<li><a title="scalecodec.types.VecQueuedKeys" href="#scalecodec.types.VecQueuedKeys">VecQueuedKeys</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.Vec.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

    result = []
    for _ in range(0, element_count):
        element = self.process_type(self.sub_type)
        self.elements.append(element)
        result.append(element.value)

    return result</code></pre>
</details>
</dd>
<dt id="scalecodec.types.Vec.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if type(value) is not list:
        raise ValueError(&#34;Provided value is not a list&#34;)

    # encode element count to Compact&lt;u32&gt;
    element_count_compact = CompactU32()

    element_count_compact.encode(len(value))

    data = element_count_compact.data

    for element in value:

        element_obj = self.get_decoder_class(self.sub_type, metadata=self.metadata)
        data += element_obj.encode(element)

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecNextAuthority"><code class="flex name class">
<span>class <span class="ident">VecNextAuthority</span></span>
<span>(</span><span>data=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecNextAuthority(Vec):
    type_string = &#39;Vec&lt;NextAuthority&gt;&#39;

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        result = []
        for _ in range(0, element_count):
            element = self.process_type(&#39;NextAuthority&#39;)
            self.elements.append(element)
            result.append(element.value)

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Vec" href="#scalecodec.types.Vec">Vec</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecNextAuthority.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecNextAuthority.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

    result = []
    for _ in range(0, element_count):
        element = self.process_type(&#39;NextAuthority&#39;)
        self.elements.append(element)
        result.append(element.value)

    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Vec" href="#scalecodec.types.Vec">Vec</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Vec.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecQueuedKeys"><code class="flex name class">
<span>class <span class="ident">VecQueuedKeys</span></span>
<span>(</span><span>data=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecQueuedKeys(Vec):
    type_string = &#39;Vec&lt;(ValidatorId, Keys)&gt;&#39;

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
        result = []
        for _ in range(0, element_count):
            element = self.process_type(&#39;QueuedKeys&#39;)
            self.elements.append(element)
            result.append(element.value)

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Vec" href="#scalecodec.types.Vec">Vec</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecQueuedKeys.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecQueuedKeys.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value
    result = []
    for _ in range(0, element_count):
        element = self.process_type(&#39;QueuedKeys&#39;)
        self.elements.append(element)
        result.append(element.value)

    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Vec" href="#scalecodec.types.Vec">Vec</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Vec.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecU8Length16"><code class="flex name class">
<span>class <span class="ident">VecU8Length16</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecU8Length16(ScaleType):
    type_string = &#39;[u8; 16]&#39;

    def process(self):
        value = self.get_next_bytes(16)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 34:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 16 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecU8Length16.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecU8Length16.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    value = self.get_next_bytes(16)
    try:
        return value.decode()
    except UnicodeDecodeError:
        return value.hex()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.VecU8Length16.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 34:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 16 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecU8Length2"><code class="flex name class">
<span>class <span class="ident">VecU8Length2</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecU8Length2(ScaleType):
    type_string = &#39;[u8; 2]&#39;

    def process(self):
        value = self.get_next_bytes(2)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 6:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 2 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecU8Length2.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecU8Length2.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    value = self.get_next_bytes(2)
    try:
        return value.decode()
    except UnicodeDecodeError:
        return value.hex()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.VecU8Length2.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 6:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 2 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecU8Length32"><code class="flex name class">
<span>class <span class="ident">VecU8Length32</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecU8Length32(ScaleType):
    type_string = &#39;[u8; 32]&#39;

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(32).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 66:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 32 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecU8Length32.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecU8Length32.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return &#39;0x{}&#39;.format(self.get_next_bytes(32).hex())</code></pre>
</details>
</dd>
<dt id="scalecodec.types.VecU8Length32.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 66:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 32 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecU8Length4"><code class="flex name class">
<span>class <span class="ident">VecU8Length4</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecU8Length4(ScaleType):
    type_string = &#39;[u8; 4]&#39;

    def process(self):
        value = self.get_next_bytes(4)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 10:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 4 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.block.ConsensusEngineId" href="block.html#scalecodec.block.ConsensusEngineId">ConsensusEngineId</a></li>
<li><a title="scalecodec.types.KeyTypeId" href="#scalecodec.types.KeyTypeId">KeyTypeId</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecU8Length4.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecU8Length4.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    value = self.get_next_bytes(4)
    try:
        return value.decode()
    except UnicodeDecodeError:
        return value.hex()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.VecU8Length4.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 10:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 4 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecU8Length64"><code class="flex name class">
<span>class <span class="ident">VecU8Length64</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecU8Length64(ScaleType):
    type_string = &#39;[u8; 64]&#39;

    def process(self):
        return &#39;0x{}&#39;.format(self.get_next_bytes(64).hex())

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 130:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 64 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecU8Length64.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecU8Length64.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return &#39;0x{}&#39;.format(self.get_next_bytes(64).hex())</code></pre>
</details>
</dd>
<dt id="scalecodec.types.VecU8Length64.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 130:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 64 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VecU8Length8"><code class="flex name class">
<span>class <span class="ident">VecU8Length8</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VecU8Length8(ScaleType):
    type_string = &#39;[u8; 8]&#39;

    def process(self):
        value = self.get_next_bytes(8)
        try:
            return value.decode()
        except UnicodeDecodeError:
            return value.hex()

    def process_encode(self, value):
        if value[0:2] != &#39;0x&#39; and len(value) == 18:
            raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 8 bytes long&#39;)
        return ScaleBytes(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VecU8Length8.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VecU8Length8.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    value = self.get_next_bytes(8)
    try:
        return value.decode()
    except UnicodeDecodeError:
        return value.hex()</code></pre>
</details>
</dd>
<dt id="scalecodec.types.VecU8Length8.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):
    if value[0:2] != &#39;0x&#39; and len(value) == 18:
        raise ValueError(&#39;Value should start with &#34;0x&#34; and should be 8 bytes long&#39;)
    return ScaleBytes(value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Vote"><code class="flex name class">
<span>class <span class="ident">Vote</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vote(U8):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U8" href="#scalecodec.types.U8">U8</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U8" href="#scalecodec.types.U8">U8</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U8.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VoteIndex"><code class="flex name class">
<span>class <span class="ident">VoteIndex</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoteIndex(U32):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.U32.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VoteKind"><code class="flex name class">
<span>class <span class="ident">VoteKind</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoteKind(Enum):
    value_list = [&#39;Abstain&#39;, &#39;Approve&#39;, &#39;Reject&#39;, &#39;Slash&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VoteOutcome"><code class="flex name class">
<span>class <span class="ident">VoteOutcome</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoteOutcome(ScaleType):

    def process(self):
        return list(self.get_next_bytes(32))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.types.VoteOutcome.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return list(self.get_next_bytes(32))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleType.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VoteStage"><code class="flex name class">
<span>class <span class="ident">VoteStage</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoteStage(Enum):
    value_list = [&#39;PreVoting&#39;, &#39;Commit&#39;, &#39;Voting&#39;, &#39;Completed&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VoteThreshold"><code class="flex name class">
<span>class <span class="ident">VoteThreshold</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoteThreshold(Enum):

    value_list = [&#39;SuperMajorityApprove&#39;, &#39;SuperMajorityAgainst&#39;, &#39;SimpleMajority&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VoteType"><code class="flex name class">
<span>class <span class="ident">VoteType</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoteType(Enum):

    type_string = &#39;voting::VoteType&#39;

    value_list = [&#39;Binary&#39;, &#39;MultiOption&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VoteType.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.VoterInfo"><code class="flex name class">
<span>class <span class="ident">VoterInfo</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoterInfo(Struct):
    type_string = &#39;VoterInfo&lt;Balance&gt;&#39;

    type_mapping = (
        (&#39;last_active&#39;, &#39;VoteIndex&#39;),
        (&#39;last_win&#39;, &#39;VoteIndex&#39;),
        (&#39;pot&#39;, &#39;Balance&#39;),
        (&#39;stake&#39;, &#39;Balance&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.VoterInfo.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
<dt id="scalecodec.types.VoterInfo.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.Votes"><code class="flex name class">
<span>class <span class="ident">Votes</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Votes(Struct):
    type_mapping = (
        (&#39;index&#39;, &#39;ProposalIndex&#39;),
        (&#39;threshold&#39;, &#39;MemberCount&#39;),
        (&#39;ayes&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
        (&#39;nays&#39;, &#39;Vec&lt;AccountId&gt;&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.Votes.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.WinningDataEntry"><code class="flex name class">
<span>class <span class="ident">WinningDataEntry</span></span>
<span>(</span><span>data, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WinningDataEntry(Struct):
    type_mapping = (
        (&#39;AccountId&#39;, &#39;AccountId&#39;),
        (&#39;ParaIdOf&#39;, &#39;ParaIdOf&#39;),
        (&#39;BalanceOf&#39;, &#39;BalanceOf&#39;),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.types.WinningDataEntry.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<section class="desc"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.types.WithdrawReasons"><code class="flex name class">
<span>class <span class="ident">WithdrawReasons</span></span>
<span>(</span><span>data, value_list=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WithdrawReasons(Enum):

    value_list = [&#39;TransactionPayment&#39;, &#39;Transfer&#39;, &#39;Reserve&#39;, &#39;Fee&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.debug" href="base.html#scalecodec.base.ScaleDecoder.debug">debug</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scalecodec" href="index.html">scalecodec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scalecodec.types.AccountId" href="#scalecodec.types.AccountId">AccountId</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.AccountId.process_encode" href="#scalecodec.types.AccountId.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.AccountIndex" href="#scalecodec.types.AccountIndex">AccountIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.AccountInfo" href="#scalecodec.types.AccountInfo">AccountInfo</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.AccountInfo.type_mapping" href="#scalecodec.types.AccountInfo.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.AccountInfo.type_string" href="#scalecodec.types.AccountInfo.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Address" href="#scalecodec.types.Address">Address</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Address.process" href="#scalecodec.types.Address.process">process</a></code></li>
<li><code><a title="scalecodec.types.Address.process_encode" href="#scalecodec.types.Address.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.Address.serialize" href="#scalecodec.types.Address.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ApprovalFlag" href="#scalecodec.types.ApprovalFlag">ApprovalFlag</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Attestation" href="#scalecodec.types.Attestation">Attestation</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.AuthorityId" href="#scalecodec.types.AuthorityId">AuthorityId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.AuthorityWeight" href="#scalecodec.types.AuthorityWeight">AuthorityWeight</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.BabeAuthorityWeight" href="#scalecodec.types.BabeAuthorityWeight">BabeAuthorityWeight</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Balance" href="#scalecodec.types.Balance">Balance</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.BalanceLock" href="#scalecodec.types.BalanceLock">BalanceLock</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.BalanceLock.type_mapping" href="#scalecodec.types.BalanceLock.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.BalanceLock.type_string" href="#scalecodec.types.BalanceLock.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.BalanceOf" href="#scalecodec.types.BalanceOf">BalanceOf</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Bidder" href="#scalecodec.types.Bidder">Bidder</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Bidder.type_string" href="#scalecodec.types.Bidder.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.BlockAndTime" href="#scalecodec.types.BlockAndTime">BlockAndTime</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.BlockAndTime.type_mapping" href="#scalecodec.types.BlockAndTime.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.BlockAttestations" href="#scalecodec.types.BlockAttestations">BlockAttestations</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.BlockAttestations.type_mapping" href="#scalecodec.types.BlockAttestations.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.BlockNumber" href="#scalecodec.types.BlockNumber">BlockNumber</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.BlockchainTimestamp" href="#scalecodec.types.BlockchainTimestamp">BlockchainTimestamp</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.BlockchainTimestamp.type_mapping" href="#scalecodec.types.BlockchainTimestamp.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.BlockchainTimestamp.type_string" href="#scalecodec.types.BlockchainTimestamp.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Bool" href="#scalecodec.types.Bool">Bool</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Bool.process" href="#scalecodec.types.Bool.process">process</a></code></li>
<li><code><a title="scalecodec.types.Bool.process_encode" href="#scalecodec.types.Bool.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.BoxProposal" href="#scalecodec.types.BoxProposal">BoxProposal</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.BoxProposal.process" href="#scalecodec.types.BoxProposal.process">process</a></code></li>
<li><code><a title="scalecodec.types.BoxProposal.process_encode" href="#scalecodec.types.BoxProposal.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.BoxProposal.type_string" href="#scalecodec.types.BoxProposal.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Bytes" href="#scalecodec.types.Bytes">Bytes</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Bytes.process" href="#scalecodec.types.Bytes.process">process</a></code></li>
<li><code><a title="scalecodec.types.Bytes.process_encode" href="#scalecodec.types.Bytes.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.Bytes.type_string" href="#scalecodec.types.Bytes.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Call" href="#scalecodec.types.Call">Call</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Call.process" href="#scalecodec.types.Call.process">process</a></code></li>
<li><code><a title="scalecodec.types.Call.process_encode" href="#scalecodec.types.Call.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.Call.type_string" href="#scalecodec.types.Call.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Category" href="#scalecodec.types.Category">Category</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Category.type_mapping" href="#scalecodec.types.Category.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.Category.type_string" href="#scalecodec.types.Category.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.CategoryId" href="#scalecodec.types.CategoryId">CategoryId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ChildPositionInParentCategory" href="#scalecodec.types.ChildPositionInParentCategory">ChildPositionInParentCategory</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.ChildPositionInParentCategory.type_mapping" href="#scalecodec.types.ChildPositionInParentCategory.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.CodeHash" href="#scalecodec.types.CodeHash">CodeHash</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Compact" href="#scalecodec.types.Compact">Compact</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Compact.process" href="#scalecodec.types.Compact.process">process</a></code></li>
<li><code><a title="scalecodec.types.Compact.process_compact_bytes" href="#scalecodec.types.Compact.process_compact_bytes">process_compact_bytes</a></code></li>
<li><code><a title="scalecodec.types.Compact.process_encode" href="#scalecodec.types.Compact.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.CompactMoment" href="#scalecodec.types.CompactMoment">CompactMoment</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.CompactMoment.process" href="#scalecodec.types.CompactMoment.process">process</a></code></li>
<li><code><a title="scalecodec.types.CompactMoment.serialize" href="#scalecodec.types.CompactMoment.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.CompactU32" href="#scalecodec.types.CompactU32">CompactU32</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.CompactU32.process" href="#scalecodec.types.CompactU32.process">process</a></code></li>
<li><code><a title="scalecodec.types.CompactU32.process_encode" href="#scalecodec.types.CompactU32.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.CompactU32.type_string" href="#scalecodec.types.CompactU32.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ContentId" href="#scalecodec.types.ContentId">ContentId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ContentMetadata" href="#scalecodec.types.ContentMetadata">ContentMetadata</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.ContentMetadata.type_mapping" href="#scalecodec.types.ContentMetadata.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ContentMetadataUpdate" href="#scalecodec.types.ContentMetadataUpdate">ContentMetadataUpdate</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.ContentMetadataUpdate.type_mapping" href="#scalecodec.types.ContentMetadataUpdate.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ContentVisibility" href="#scalecodec.types.ContentVisibility">ContentVisibility</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Conviction" href="#scalecodec.types.Conviction">Conviction</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Conviction.CONVICTION_MASK" href="#scalecodec.types.Conviction.CONVICTION_MASK">CONVICTION_MASK</a></code></li>
<li><code><a title="scalecodec.types.Conviction.DEFAULT_CONVICTION" href="#scalecodec.types.Conviction.DEFAULT_CONVICTION">DEFAULT_CONVICTION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Data" href="#scalecodec.types.Data">Data</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Data.process" href="#scalecodec.types.Data.process">process</a></code></li>
<li><code><a title="scalecodec.types.Data.process_encode" href="#scalecodec.types.Data.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.Data.type_mapping" href="#scalecodec.types.Data.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.DataObject" href="#scalecodec.types.DataObject">DataObject</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.DataObject.type_mapping" href="#scalecodec.types.DataObject.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.DataObjectStorageRelationshipId" href="#scalecodec.types.DataObjectStorageRelationshipId">DataObjectStorageRelationshipId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.DataObjectTypeId" href="#scalecodec.types.DataObjectTypeId">DataObjectTypeId</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.DataObjectTypeId.type_string" href="#scalecodec.types.DataObjectTypeId.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.DownloadSession" href="#scalecodec.types.DownloadSession">DownloadSession</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.DownloadSession.type_mapping" href="#scalecodec.types.DownloadSession.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.DownloadSessionId" href="#scalecodec.types.DownloadSessionId">DownloadSessionId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.DownloadState" href="#scalecodec.types.DownloadState">DownloadState</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.EcdsaSignature" href="#scalecodec.types.EcdsaSignature">EcdsaSignature</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.EcdsaSignature.process" href="#scalecodec.types.EcdsaSignature.process">process</a></code></li>
<li><code><a title="scalecodec.types.EcdsaSignature.process_encode" href="#scalecodec.types.EcdsaSignature.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.EdgewareKeys" href="#scalecodec.types.EdgewareKeys">EdgewareKeys</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.EdgewareKeys.type_mapping" href="#scalecodec.types.EdgewareKeys.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.EdgewareQueuedKeys" href="#scalecodec.types.EdgewareQueuedKeys">EdgewareQueuedKeys</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.EdgewareQueuedKeys.type_mapping" href="#scalecodec.types.EdgewareQueuedKeys.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.EdgewareQueuedKeys.type_string" href="#scalecodec.types.EdgewareQueuedKeys.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.EntryMethod" href="#scalecodec.types.EntryMethod">EntryMethod</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Enum" href="#scalecodec.types.Enum">Enum</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Enum.process" href="#scalecodec.types.Enum.process">process</a></code></li>
<li><code><a title="scalecodec.types.Enum.process_encode" href="#scalecodec.types.Enum.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.Enum.type_mapping" href="#scalecodec.types.Enum.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.Enum.value_list" href="#scalecodec.types.Enum.value_list">value_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Era" href="#scalecodec.types.Era">Era</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Era.process" href="#scalecodec.types.Era.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.EraIndex" href="#scalecodec.types.EraIndex">EraIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.EraPoints" href="#scalecodec.types.EraPoints">EraPoints</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.EraPoints.type_mapping" href="#scalecodec.types.EraPoints.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.EraRewards" href="#scalecodec.types.EraRewards">EraRewards</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.EraRewards.type_mapping" href="#scalecodec.types.EraRewards.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.EthereumAddress" href="#scalecodec.types.EthereumAddress">EthereumAddress</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.EthereumAddress.process" href="#scalecodec.types.EthereumAddress.process">process</a></code></li>
<li><code><a title="scalecodec.types.EthereumAddress.process_encode" href="#scalecodec.types.EthereumAddress.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Exposure" href="#scalecodec.types.Exposure">Exposure</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Exposure.type_mapping" href="#scalecodec.types.Exposure.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.Exposure.type_string" href="#scalecodec.types.Exposure.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Gas" href="#scalecodec.types.Gas">Gas</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.H160" href="#scalecodec.types.H160">H160</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.H160.process" href="#scalecodec.types.H160.process">process</a></code></li>
<li><code><a title="scalecodec.types.H160.process_encode" href="#scalecodec.types.H160.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.H256" href="#scalecodec.types.H256">H256</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.H256.process" href="#scalecodec.types.H256.process">process</a></code></li>
<li><code><a title="scalecodec.types.H256.process_encode" href="#scalecodec.types.H256.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.H512" href="#scalecodec.types.H512">H512</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.H512.process" href="#scalecodec.types.H512.process">process</a></code></li>
<li><code><a title="scalecodec.types.H512.process_encode" href="#scalecodec.types.H512.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Hash" href="#scalecodec.types.Hash">Hash</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.HeadData" href="#scalecodec.types.HeadData">HeadData</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.HexBytes" href="#scalecodec.types.HexBytes">HexBytes</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.HexBytes.process" href="#scalecodec.types.HexBytes.process">process</a></code></li>
<li><code><a title="scalecodec.types.HexBytes.process_encode" href="#scalecodec.types.HexBytes.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.IPNSIdentity" href="#scalecodec.types.IPNSIdentity">IPNSIdentity</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Identity" href="#scalecodec.types.Identity">Identity</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.IdentityType" href="#scalecodec.types.IdentityType">IdentityType</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.IncludedBlocks" href="#scalecodec.types.IncludedBlocks">IncludedBlocks</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.IncludedBlocks.type_mapping" href="#scalecodec.types.IncludedBlocks.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Index" href="#scalecodec.types.Index">Index</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.IndividualExposure" href="#scalecodec.types.IndividualExposure">IndividualExposure</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.IndividualExposure.type_mapping" href="#scalecodec.types.IndividualExposure.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.IndividualExposure.type_string" href="#scalecodec.types.IndividualExposure.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.InherentOfflineReport" href="#scalecodec.types.InherentOfflineReport">InherentOfflineReport</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.InputValidationLengthConstraint" href="#scalecodec.types.InputValidationLengthConstraint">InputValidationLengthConstraint</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.InputValidationLengthConstraint.type_mapping" href="#scalecodec.types.InputValidationLengthConstraint.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Key" href="#scalecodec.types.Key">Key</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.KeyTypeId" href="#scalecodec.types.KeyTypeId">KeyTypeId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.KeyValue" href="#scalecodec.types.KeyValue">KeyValue</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.KeyValue.type_mapping" href="#scalecodec.types.KeyValue.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.KeyValue.type_string" href="#scalecodec.types.KeyValue.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.LegacyKeys" href="#scalecodec.types.LegacyKeys">LegacyKeys</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.LegacyKeys.type_mapping" href="#scalecodec.types.LegacyKeys.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.LegacyQueuedKeys" href="#scalecodec.types.LegacyQueuedKeys">LegacyQueuedKeys</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.LegacyQueuedKeys.type_mapping" href="#scalecodec.types.LegacyQueuedKeys.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.LegacyQueuedKeys.type_string" href="#scalecodec.types.LegacyQueuedKeys.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.LiaisonJudgement" href="#scalecodec.types.LiaisonJudgement">LiaisonJudgement</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Linkage" href="#scalecodec.types.Linkage">Linkage</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Linkage.type_mapping" href="#scalecodec.types.Linkage.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.Linkage.type_string" href="#scalecodec.types.Linkage.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.LockPeriods" href="#scalecodec.types.LockPeriods">LockPeriods</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.MemberId" href="#scalecodec.types.MemberId">MemberId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ModerationAction" href="#scalecodec.types.ModerationAction">ModerationAction</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.ModerationAction.type_mapping" href="#scalecodec.types.ModerationAction.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Moment" href="#scalecodec.types.Moment">Moment</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.NewAccountOutcome" href="#scalecodec.types.NewAccountOutcome">NewAccountOutcome</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Null" href="#scalecodec.types.Null">Null</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Null.process" href="#scalecodec.types.Null.process">process</a></code></li>
<li><code><a title="scalecodec.types.Null.process_encode" href="#scalecodec.types.Null.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.OpaqueMultiaddr" href="#scalecodec.types.OpaqueMultiaddr">OpaqueMultiaddr</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.OpaqueNetworkState" href="#scalecodec.types.OpaqueNetworkState">OpaqueNetworkState</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.OpaqueNetworkState.type_mapping" href="#scalecodec.types.OpaqueNetworkState.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.OpaquePeerId" href="#scalecodec.types.OpaquePeerId">OpaquePeerId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Option" href="#scalecodec.types.Option">Option</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Option.process" href="#scalecodec.types.Option.process">process</a></code></li>
<li><code><a title="scalecodec.types.Option.process_encode" href="#scalecodec.types.Option.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.OptionBytes" href="#scalecodec.types.OptionBytes">OptionBytes</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.OptionBytes.process" href="#scalecodec.types.OptionBytes.process">process</a></code></li>
<li><code><a title="scalecodec.types.OptionBytes.type_string" href="#scalecodec.types.OptionBytes.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.PaidMembershipTerms" href="#scalecodec.types.PaidMembershipTerms">PaidMembershipTerms</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.PaidMembershipTerms.type_mapping" href="#scalecodec.types.PaidMembershipTerms.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.PaidTermId" href="#scalecodec.types.PaidTermId">PaidTermId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ParaId" href="#scalecodec.types.ParaId">ParaId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ParachainDispatchOrigin" href="#scalecodec.types.ParachainDispatchOrigin">ParachainDispatchOrigin</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Perbill" href="#scalecodec.types.Perbill">Perbill</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Permill" href="#scalecodec.types.Permill">Permill</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Points" href="#scalecodec.types.Points">Points</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Post" href="#scalecodec.types.Post">Post</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Post.type_mapping" href="#scalecodec.types.Post.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.Post.type_string" href="#scalecodec.types.Post.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.PostId" href="#scalecodec.types.PostId">PostId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.PostTextChange" href="#scalecodec.types.PostTextChange">PostTextChange</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.PostTextChange.type_mapping" href="#scalecodec.types.PostTextChange.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.PostTextChange.type_string" href="#scalecodec.types.PostTextChange.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.PrefabWasmModule" href="#scalecodec.types.PrefabWasmModule">PrefabWasmModule</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.PrefabWasmModule.type_mapping" href="#scalecodec.types.PrefabWasmModule.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.PrefabWasmModule.type_string" href="#scalecodec.types.PrefabWasmModule.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Profile" href="#scalecodec.types.Profile">Profile</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Profile.type_mapping" href="#scalecodec.types.Profile.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.PropIndex" href="#scalecodec.types.PropIndex">PropIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Proposal" href="#scalecodec.types.Proposal">Proposal</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ProposalCategory" href="#scalecodec.types.ProposalCategory">ProposalCategory</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ProposalContents" href="#scalecodec.types.ProposalContents">ProposalContents</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ProposalIndex" href="#scalecodec.types.ProposalIndex">ProposalIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ProposalPreimage" href="#scalecodec.types.ProposalPreimage">ProposalPreimage</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.ProposalPreimage.process" href="#scalecodec.types.ProposalPreimage.process">process</a></code></li>
<li><code><a title="scalecodec.types.ProposalPreimage.type_mapping" href="#scalecodec.types.ProposalPreimage.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.ProposalPreimage.type_string" href="#scalecodec.types.ProposalPreimage.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ProposalStage" href="#scalecodec.types.ProposalStage">ProposalStage</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ProposalStatus" href="#scalecodec.types.ProposalStatus">ProposalStatus</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ProposalTitle" href="#scalecodec.types.ProposalTitle">ProposalTitle</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.QueuedKeys" href="#scalecodec.types.QueuedKeys">QueuedKeys</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.QueuedKeys.type_mapping" href="#scalecodec.types.QueuedKeys.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.QueuedKeys.type_string" href="#scalecodec.types.QueuedKeys.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.RawAddress" href="#scalecodec.types.RawAddress">RawAddress</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ReferendumIndex" href="#scalecodec.types.ReferendumIndex">ReferendumIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ReportIdOf" href="#scalecodec.types.ReportIdOf">ReportIdOf</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.RewardDestination" href="#scalecodec.types.RewardDestination">RewardDestination</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.Role" href="#scalecodec.types.Role">Role</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.RuntimeUpgradeProposal" href="#scalecodec.types.RuntimeUpgradeProposal">RuntimeUpgradeProposal</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.RuntimeUpgradeProposal.type_mapping" href="#scalecodec.types.RuntimeUpgradeProposal.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.RuntimeUpgradeProposal.type_string" href="#scalecodec.types.RuntimeUpgradeProposal.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.SchemaId" href="#scalecodec.types.SchemaId">SchemaId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.SessionIndex" href="#scalecodec.types.SessionIndex">SessionIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.SessionKey" href="#scalecodec.types.SessionKey">SessionKey</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.SessionKeysSubstrate" href="#scalecodec.types.SessionKeysSubstrate">SessionKeysSubstrate</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.SessionKeysSubstrate.type_mapping" href="#scalecodec.types.SessionKeysSubstrate.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Set" href="#scalecodec.types.Set">Set</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Set.process" href="#scalecodec.types.Set.process">process</a></code></li>
<li><code><a title="scalecodec.types.Set.process_encode" href="#scalecodec.types.Set.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.Set.value_list" href="#scalecodec.types.Set.value_list">value_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.SetIndex" href="#scalecodec.types.SetIndex">SetIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.SlashJournalEntry" href="#scalecodec.types.SlashJournalEntry">SlashJournalEntry</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.SlashJournalEntry.type_mapping" href="#scalecodec.types.SlashJournalEntry.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.StakingLedger" href="#scalecodec.types.StakingLedger">StakingLedger</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.StakingLedger.type_mapping" href="#scalecodec.types.StakingLedger.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.StakingLedger.type_string" href="#scalecodec.types.StakingLedger.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.StorageHasher" href="#scalecodec.types.StorageHasher">StorageHasher</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.StorageHasher.is_blake2_128" href="#scalecodec.types.StorageHasher.is_blake2_128">is_blake2_128</a></code></li>
<li><code><a title="scalecodec.types.StorageHasher.is_blake2_256" href="#scalecodec.types.StorageHasher.is_blake2_256">is_blake2_256</a></code></li>
<li><code><a title="scalecodec.types.StorageHasher.is_twoblake2_128_concat" href="#scalecodec.types.StorageHasher.is_twoblake2_128_concat">is_twoblake2_128_concat</a></code></li>
<li><code><a title="scalecodec.types.StorageHasher.is_twox128" href="#scalecodec.types.StorageHasher.is_twox128">is_twox128</a></code></li>
<li><code><a title="scalecodec.types.StorageHasher.is_twox256" href="#scalecodec.types.StorageHasher.is_twox256">is_twox256</a></code></li>
<li><code><a title="scalecodec.types.StorageHasher.is_twox64_concat" href="#scalecodec.types.StorageHasher.is_twox64_concat">is_twox64_concat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.StoredPendingChange" href="#scalecodec.types.StoredPendingChange">StoredPendingChange</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.StoredPendingChange.type_mapping" href="#scalecodec.types.StoredPendingChange.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.StoredState" href="#scalecodec.types.StoredState">StoredState</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.String" href="#scalecodec.types.String">String</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.String.process" href="#scalecodec.types.String.process">process</a></code></li>
<li><code><a title="scalecodec.types.String.process_encode" href="#scalecodec.types.String.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Struct" href="#scalecodec.types.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Struct.process" href="#scalecodec.types.Struct.process">process</a></code></li>
<li><code><a title="scalecodec.types.Struct.process_encode" href="#scalecodec.types.Struct.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.SubscriptionId" href="#scalecodec.types.SubscriptionId">SubscriptionId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.TallyResult" href="#scalecodec.types.TallyResult">TallyResult</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.TallyResult.type_mapping" href="#scalecodec.types.TallyResult.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.TallyResult.type_string" href="#scalecodec.types.TallyResult.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.TallyType" href="#scalecodec.types.TallyType">TallyType</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.TallyType.type_string" href="#scalecodec.types.TallyType.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Thread" href="#scalecodec.types.Thread">Thread</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Thread.type_mapping" href="#scalecodec.types.Thread.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.Thread.type_string" href="#scalecodec.types.Thread.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ThreadId" href="#scalecodec.types.ThreadId">ThreadId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.U128" href="#scalecodec.types.U128">U128</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.U128.process" href="#scalecodec.types.U128.process">process</a></code></li>
<li><code><a title="scalecodec.types.U128.process_encode" href="#scalecodec.types.U128.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.U16" href="#scalecodec.types.U16">U16</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.U16.process" href="#scalecodec.types.U16.process">process</a></code></li>
<li><code><a title="scalecodec.types.U16.process_encode" href="#scalecodec.types.U16.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.U32" href="#scalecodec.types.U32">U32</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.U32.process" href="#scalecodec.types.U32.process">process</a></code></li>
<li><code><a title="scalecodec.types.U32.process_encode" href="#scalecodec.types.U32.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.U64" href="#scalecodec.types.U64">U64</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.U64.process" href="#scalecodec.types.U64.process">process</a></code></li>
<li><code><a title="scalecodec.types.U64.process_encode" href="#scalecodec.types.U64.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.U8" href="#scalecodec.types.U8">U8</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.U8.process" href="#scalecodec.types.U8.process">process</a></code></li>
<li><code><a title="scalecodec.types.U8.process_encode" href="#scalecodec.types.U8.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.UnlockChunk" href="#scalecodec.types.UnlockChunk">UnlockChunk</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.UnlockChunk.type_mapping" href="#scalecodec.types.UnlockChunk.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.UnlockChunk.type_string" href="#scalecodec.types.UnlockChunk.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.UpwardMessage" href="#scalecodec.types.UpwardMessage">UpwardMessage</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.UpwardMessage.type_mapping" href="#scalecodec.types.UpwardMessage.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Url" href="#scalecodec.types.Url">Url</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.UserInfo" href="#scalecodec.types.UserInfo">UserInfo</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.UserInfo.type_mapping" href="#scalecodec.types.UserInfo.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ValidatorId" href="#scalecodec.types.ValidatorId">ValidatorId</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.ValidatorPrefs" href="#scalecodec.types.ValidatorPrefs">ValidatorPrefs</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.ValidatorPrefs.type_mapping" href="#scalecodec.types.ValidatorPrefs.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.ValidatorPrefs.type_string" href="#scalecodec.types.ValidatorPrefs.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.ValidatorPrefsLegacy" href="#scalecodec.types.ValidatorPrefsLegacy">ValidatorPrefsLegacy</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.ValidatorPrefsLegacy.type_mapping" href="#scalecodec.types.ValidatorPrefsLegacy.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.ValidatorPrefsLegacy.type_string" href="#scalecodec.types.ValidatorPrefsLegacy.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Vec" href="#scalecodec.types.Vec">Vec</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Vec.process" href="#scalecodec.types.Vec.process">process</a></code></li>
<li><code><a title="scalecodec.types.Vec.process_encode" href="#scalecodec.types.Vec.process_encode">process_encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecNextAuthority" href="#scalecodec.types.VecNextAuthority">VecNextAuthority</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecNextAuthority.process" href="#scalecodec.types.VecNextAuthority.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecNextAuthority.type_string" href="#scalecodec.types.VecNextAuthority.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecQueuedKeys" href="#scalecodec.types.VecQueuedKeys">VecQueuedKeys</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecQueuedKeys.process" href="#scalecodec.types.VecQueuedKeys.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecQueuedKeys.type_string" href="#scalecodec.types.VecQueuedKeys.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecU8Length16" href="#scalecodec.types.VecU8Length16">VecU8Length16</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecU8Length16.process" href="#scalecodec.types.VecU8Length16.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length16.process_encode" href="#scalecodec.types.VecU8Length16.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length16.type_string" href="#scalecodec.types.VecU8Length16.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecU8Length2" href="#scalecodec.types.VecU8Length2">VecU8Length2</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecU8Length2.process" href="#scalecodec.types.VecU8Length2.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length2.process_encode" href="#scalecodec.types.VecU8Length2.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length2.type_string" href="#scalecodec.types.VecU8Length2.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecU8Length32" href="#scalecodec.types.VecU8Length32">VecU8Length32</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecU8Length32.process" href="#scalecodec.types.VecU8Length32.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length32.process_encode" href="#scalecodec.types.VecU8Length32.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length32.type_string" href="#scalecodec.types.VecU8Length32.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecU8Length4" href="#scalecodec.types.VecU8Length4">VecU8Length4</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecU8Length4.process" href="#scalecodec.types.VecU8Length4.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length4.process_encode" href="#scalecodec.types.VecU8Length4.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length4.type_string" href="#scalecodec.types.VecU8Length4.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecU8Length64" href="#scalecodec.types.VecU8Length64">VecU8Length64</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecU8Length64.process" href="#scalecodec.types.VecU8Length64.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length64.process_encode" href="#scalecodec.types.VecU8Length64.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length64.type_string" href="#scalecodec.types.VecU8Length64.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VecU8Length8" href="#scalecodec.types.VecU8Length8">VecU8Length8</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VecU8Length8.process" href="#scalecodec.types.VecU8Length8.process">process</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length8.process_encode" href="#scalecodec.types.VecU8Length8.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.types.VecU8Length8.type_string" href="#scalecodec.types.VecU8Length8.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Vote" href="#scalecodec.types.Vote">Vote</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.VoteIndex" href="#scalecodec.types.VoteIndex">VoteIndex</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.VoteKind" href="#scalecodec.types.VoteKind">VoteKind</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.VoteOutcome" href="#scalecodec.types.VoteOutcome">VoteOutcome</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VoteOutcome.process" href="#scalecodec.types.VoteOutcome.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VoteStage" href="#scalecodec.types.VoteStage">VoteStage</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.VoteThreshold" href="#scalecodec.types.VoteThreshold">VoteThreshold</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.types.VoteType" href="#scalecodec.types.VoteType">VoteType</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VoteType.type_string" href="#scalecodec.types.VoteType.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.VoterInfo" href="#scalecodec.types.VoterInfo">VoterInfo</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.VoterInfo.type_mapping" href="#scalecodec.types.VoterInfo.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.types.VoterInfo.type_string" href="#scalecodec.types.VoterInfo.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.Votes" href="#scalecodec.types.Votes">Votes</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.Votes.type_mapping" href="#scalecodec.types.Votes.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.WinningDataEntry" href="#scalecodec.types.WinningDataEntry">WinningDataEntry</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.types.WinningDataEntry.type_mapping" href="#scalecodec.types.WinningDataEntry.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.types.WithdrawReasons" href="#scalecodec.types.WithdrawReasons">WithdrawReasons</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>